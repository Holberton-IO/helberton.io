{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;;;AAAyC;;AAEzC,oBAAoB;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,0DAAM;AAC1B;AACA;AACA;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;;;;ACjB2C;AACD;AACS;AACV;AACM;;;AAGhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;;AAGA;;;AAGA,+BAA+B,uDAAW;;AAE1C;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA,6BAA6B,iDAAc;AAC3C;;AAEA;AACA;AACA;AACA;AACA,yCAAyC,6DAA0B;AACnE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,2CAA2C,iDAAc;AACzD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yCAAyC,6DAA0B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,2CAA2C,iDAAc;AACzD;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,yDAAyD,2BAA2B;AACpF,qDAAqD,uBAAuB;AAC5E;AACA;AACA;;AAEA,SAAS;;AAET;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAmC,6DAAU;AAC7C;AACA;;;;AAIA;;AAEA;AACA;AACA,0EAA0E;;AAE1E;AACA;AACA,SAAS;AACT;AACA,wCAAwC,6DAA0B;AAClE;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU;AACV;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA,yBAAyB,kDAAkB;AAC3C,oBAAoB,mDAAmB;AACvC,8BAA8B,mEAAqB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,iEAAe,UAAU;;;;;;;;;;;;;;;;ACxLiB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,eAAe,4DAAK;AACpB;;;AAGA;;AAEA,iEAAe,WAAW;;;;;;;;;;;;;AC9CgB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4DAAK;AACxB;AACA;;;;;AAKA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;;;;;;ACvB+B;AACM;AACY;AACD;;AAEjD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA,sBAAsB,kDAAM;AAC5B;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,wDAAM;AACjC;AACA;AACA,4BAA4B,wDAAiB;AAC7C;AACA;AACA;;AAEA;AACA,oBAAoB,8DAAU;AAC9B;AACA;;AAEA;;;;;;;;;;;;;;;;;;;ACvFuC;AACA;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,iEAAe,MAAM;;;;;;;;;;;;;;;;;;;;AClDa;AACM;AACQ;AACO;AACZ;;;AAG3C,8BAA8B,kDAAM;;AAEpC;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B,wDAAM;AACjC;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA,iEAAe,eAAe;;;;;;;;;;;;;;;;;;;;;;ACpCC;AACS;AACA;AACc;AACR;AACS;AACZ;;AAE3C,6BAA6B,+CAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,2BAA2B,wDAAM;AACjC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,kEAAoB;AACjD,2BAA2B,kEAAoB;AAC/C,qCAAqC,kEAAoB;AACzD,4BAA4B,kEAAoB;AAChD,gCAAgC,kEAAoB;;AAEpD,6BAA6B,gEAAS,KAAK,4DAAK,sBAAsB,4DAAK;;;AAG3E;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,yDAAK;AACb;AACA;;AAEA;AACA;;AAEA,iEAAe,cAAc;;;;;;;;;;;;;;;;;;;;;;AC1EK;AACM;AACA;AACC;AACb;AACkB;AACH;;AAE3C,yBAAyB,kDAAM;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,2BAA2B,wDAAM;AACjC;AACA;AACA;AACA;;;AAGA;;AAEA;;AAEA,+BAA+B,0DAAM,KAAK,yDAAK;AAC/C;;AAEA;AACA;AACA;AACA,kCAAkC,oDAAY;AAC9C;;AAEA,4BAA4B,8CAAK;AACjC,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA,iEAAe,UAAU;;;;;;;;;;;;;;;;;;;;;;;;;;AC1Da;AACV;AACY;AACM;AACI;AACR;AACV;AACA;AAC+B;AACb;AACsB;;AAExE;AACA,UAAU,mDAAU;AACpB,UAAU,oDAAiB;AAC3B,UAAU,8CAAK;AACf,UAAU,iDAAc;AACxB,UAAU,sDAAmB;AAC7B,UAAU,kDAAe;AACzB,UAAU,6CAAU;AACpB,UAAU,6CAAU;AACpB,UAAU,6DAAyB;AACnC,UAAU,sDAAmB;AAC7B,UAAU,kEAA8B;AACxC;;;AAGA,iEAAe,iBAAiB;;;;;;;;;;;;;;;;;;;;AC3BE;AACM;AACQ;AACO;AACZ;;;AAG3C,yBAAyB,kDAAM;;AAE/B;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA,2BAA2B,wDAAM;AACjC;AACA;;;AAGA;AACA;AACA;;AAEA,iEAAe,UAAU;;;;;;;;;;;;;;;;;;;;AC/BS;AACM;AACQ;AACO;AACZ;;;AAG3C,kCAAkC,kDAAM;;AAExC;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B,wDAAM;AACjC;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iEAAe,mBAAmB;;;;;;;;;;;;;;;;;;;;ACvCA;AACM;AACQ;AACO;AACZ;;;AAG3C,gCAAgC,kDAAM;;AAEtC;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA,6BAA6B,kEAAoB;AACjD,2BAA2B,kEAAoB;AAC/C,qCAAqC,kEAAoB;AACzD,4BAA4B,kEAAoB;AAChD,gCAAgC,kEAAoB;;AAEpD;;AAEA;AACA;AACA;AACA,2BAA2B,wDAAM;AACjC;AACA;;;AAGA;AACA;;AAEA;;AAEA,yBAAyB,6DAAM,KAAK,yDAAK;AACzC;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA,yBAAyB,yDAAK;AAC9B;AACA;;AAEA,uBAAuB,6DAAM;AAC7B;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iEAAe,iBAAiB;;;;;;;;;;;;;;;;;;;;;ACnIE;AACM;AACQ;AACO;AACZ;AACE;;AAE7C,yBAAyB,kDAAM;;AAE/B;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA,2BAA2B,wDAAM;AACjC;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,kCAAkC,0DAA0B;AAC5D,iCAAiC,0DAA0B;AAC3D;AACA;AACA;AACA;AACA;;AAEA,iEAAe,UAAU;;;;;;;;;;;;;;;;;;;;ACxCS;AACM;AACQ;AACO;AACZ;;;AAG3C,oBAAoB,kDAAM;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA,6BAA6B,kEAAoB;AACjD,2BAA2B,kEAAoB;AAC/C,qCAAqC,kEAAoB;AACzD,4BAA4B,kEAAoB;AAChD,gCAAgC,kEAAoB;AACpD;;AAEA;AACA;AACA;AACA,2BAA2B,wDAAM;AACjC;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA,iEAAe,KAAK;;;;;;;;;;;;;;;;;AC5Ec;AACM;;AAExC,wCAAwC,kDAAM;;AAE9C;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B,wDAAM;AACjC;AACA;;AAEA;;AAEA;AACA;;AAEA,iEAAe,yBAAyB;;;;;;;;;;;;;;;;;;AC5BN;AACM;AACG;;;AAG3C,6CAA6C,kDAAM;;AAEnD;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA,wBAAwB,yDAAK;AAC7B;;AAEA;;AAEA;AACA;AACA;AACA,2BAA2B,wDAAM;AACjC;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;;AAGT;AACA;;AAEA,iEAAe,8BAA8B;;;;;;;;;;;;;;;;;;;;ACnEX;AACM;AACQ;AACO;AACZ;;;AAG3C,kCAAkC,kDAAM;;AAExC;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC,4BAA4B,yDAAK;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B,wDAAM;AACjC;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;;AAGA;AACA;;;AAGA;AACA;AACA;AACA;AACA,cAAc;;AAEd;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA,oCAAoC,gDAAgD;AACpF;AACA;AACA;;AAEA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;;AAEA;AACA;;AAEA,iEAAe,mBAAmB;;;;;;;;;;;;;;;ACrHlC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,iEAAe,MAAM;;;;;;;;;;;;;;;;;ACxBrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAoB,cAAc;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC5CoE;;;AAGpE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,0DAAU;AACzB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,eAAe,2DAAW;AAC1B;;AAEA;;AAEA,iEAAe,MAAM;;;;;;;;;;;;;;;;ACtD+C;;AAEpE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,0DAAU;AAC5B;AACA;AACA;;AAEA;AACA,oBAAoB,0DAAU;AAC9B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,eAAe,2DAAW;AAC1B;;;AAGA;;AAEA,iEAAe,MAAM;;;;;;;;;;;;;;;ACtErB;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,4BAA4B;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,0CAA0C;;AAE1C;;AAEA;AACA;AACA,gCAAgC;AAChC,UAAU;AACV;AACA,gCAAgC;AAChC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iEAAe,SAAS;;;;;;;;;;;;;;;;;;;AClEO;AACiB;AACP;AACD;;AAExC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA6B,qDAAS;;AAEtC;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,iDAAK;AACxB;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA,wCAAwC;AACxC;;AAEA;AACA,8BAA8B,yDAAsB;AACpD,2BAA2B,yDAAsB,aAAa;AAC9D,6BAA6B,yDAAsB;;;AAGnD;AACA;AACA,YAAY,mDAAsB;AAClC;;AAEA;AACA;AACA,YAAY,mDAAsB;AAClC,UAAU;AACV;AACA;AACA,wDAAwD,6DAA0B;AAClF;AACA,gCAAgC,6DAA0B;AAC1D;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,uDAAuD,6DAA0B;AACjF,gCAAgC,6DAA0B;AAC1D;AACA,UAAU;;AAEV;AACA,YAAY,mDAAsB,+BAA+B,6DAA0B;AAC3F;AACA;;AAEA;;;AAGA;;AAEA;AACA;AACA;;;AAGA;AACA;;;AAGA;AACA,wCAAwC;AACxC;;AAEA;AACA,8BAA8B,yDAAsB;AACpD,2BAA2B,yDAAsB,aAAa;AAC9D,6BAA6B,yDAAsB;;AAEnD;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,mDAAsB;AAClC,UAAU;AACV;AACA;AACA,qDAAqD,6DAA0B;AAC/E;AACA,gCAAgC,6DAA0B;AAC1D;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,+CAA+C,6DAA0B;AACzE,gCAAgC,6DAA0B;AAC1D;AACA,UAAU;;AAEV;AACA,YAAY,mDAAsB,0BAA0B,6DAA0B;AACtF;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,MAAM;AACxB,6CAA6C,iDAAK;AAClD;AACA;AACA;;AAEA;;AAEA;;;AAGA,iEAAe,KAAK;;;;;;;;;;;;;;;;;;;AC/OW;AACQ;AACE;AACO;;AAEhD;AACA;AACA;AACA,+BAA+B,iDAAK;AACpC;AACA,qCAAqC,iDAAK;AAC1C,mCAAmC,iDAAK;;AAExC;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iDAAK;AAClC;;AAEA;AACA,qDAAqD,QAAQ;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,2CAAc;AAC3C,6BAA6B,2CAAc;;AAE3C,cAAc;AACd,6BAA6B,2CAAc,OAAO,oEAAiC;AACnF,6BAA6B,2CAAc,IAAI,oEAAiC;AAChF,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,uDAAoB;AAChC,YAAY,uDAAoB;AAChC;AACA;AACA;AACA;;AAEA;;AAEA;AACA,4BAA4B,4DAA+B;AAC3D;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,UAAU,KAAK,EAEN;AACT;;;AAGA;AACA;AACA;AACA,iCAAiC,6DAA0B;AAC3D,iCAAiC,6DAA0B;;AAE3D,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA,6BAA6B,iDAAK;AAClC;AACA;AACA;AACA,8BAA8B,iDAAK;AACnC;AACA;AACA;AACA,mBAAmB,qDAAS;AAC5B;;AAEA;;;AAGA,iEAAe,MAAM;;;;;;;;;;;;;;;;;;;;AChKU;AACiB;AACP;AACqB;AAC9B;AACmD;;;AAGnF;;AAEA,+BAA+B,iDAAK;AACpC;AACA,iCAAiC;;AAEjC;AACA;AACA;AACA;AACA,0CAA0C,iDAAK;AAC/C;AACA;AACA;;AAEA;AACA,gCAAgC,iDAAK;AACrC,kCAAkC,iDAAK;AACvC,qCAAqC,iDAAK;;;AAG1C;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,0CAA0C;AAC1C,uDAAuD;AACvD;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,iDAAK;AAClC;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;;AAEA;;AAEA;AACA,yCAAyC,wCAAwC,wCAAwC,yCAAyC;AAClK;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;;AAEA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA,+BAA+B,iDAAK;AACpC;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,6DAA0B;AACxD,8BAA8B,6DAA0B;AACxD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA,YAAY,4DAA+B;AAC3C;AACA,UAAU;AACV;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;;;AAGA;AACA;AACA,6BAA6B,iDAAK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA,6DAA6D,iBAAiB;AAC9E;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;;AAGA;AACA,qBAAqB,mDAAmD;AACxE,qBAAqB,qDAAqD;AAC1E;;;AAGA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,cAAc;AACd;AACA,qBAAqB,6CAA6C;AAClE,qBAAqB,+CAA+C;AACpE;AACA;;;AAGA;;;AAGA;;AAEA;AACA;;;AAGA,+BAA+B,4BAA4B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC;AACnC,+CAA+C;AAC/C;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,0BAA0B,6DAA0B,QAAQ,oEAAiC;AAC7F;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,+BAA+B,iDAAK;AACpC;;;AAGA,4BAA4B,iDAAK;AACjC;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;AAGA;;AAEA;;AAEA;AACA,sBAAsB;AACtB;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,gCAAgC,iDAAK;AACrC,gCAAgC,iDAAK;;AAErC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA,YAAY,oDAAuB;AACnC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA,YAAY,4DAA+B;AAC3C;AACA;AACA,UAAU;AACV;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,2BAA2B,kEAAe;AAC1C;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;AAIA;AACA;AACA;AACA;AACA,2BAA2B,6EAAyB;AACpD;AACA;;;AAGA;AACA,6BAA6B,iDAAK;AAClC;AACA;;AAEA;AACA;AACA;AACA,YAAY,KAAK,EAAE,EAEV,CAAC;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,iEAAe,MAAM;;;;;;;;;;;;;;;ACpxBrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA,iEAAe,KAAK;;;;;;;;;;;;;;;;AC1CW;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,UAAU,MAAM,SAAS;AAC1D;;AAEA;AACA,2BAA2B,iDAAK;AAChC;AACA;AACA;;AAEA,2BAA2B,iDAAK;AAChC;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iCAAiC,gBAAgB;AACjD,qCAAqC,gBAAgB;AACrD,wBAAwB;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe,SAAS;;;;;;;;;;;;;;;;;;;;;;;AC9DxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;ACpDA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;;;;;;;UCnCA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;;;;ACN4C;AACN;AACE;AAClB;AACC;AACmB;;;AAG1C,mBAAmB,6DAAM;AACzB,uBAAuB,mDAAU;;AAEjC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;;AAGA;;;AAGA;;AAEA,aAAa,mDAAM;AACnB;AACA,CAAC","sources":["webpack:///./src/controls.js","webpack:///./src/extensions/arraysExtensions.js","webpack:///./src/gameEngine.js","webpack:///./src/gameObjects.js","webpack:///./src/globals.js","webpack:///./src/network/client.js","webpack:///./src/network/packet.js","webpack:///./src/network/packets/direction.js","webpack:///./src/network/packets/fillArea.js","webpack:///./src/network/packets/namePacket.js","webpack:///./src/network/packets/packets.js","webpack:///./src/network/packets/ping.js","webpack:///./src/network/packets/playerRemoved.js","webpack:///./src/network/packets/playerState.js","webpack:///./src/network/packets/pong.js","webpack:///./src/network/packets/ready.js","webpack:///./src/network/packets/requestWaitingBlocks.js","webpack:///./src/network/packets/stopDrawingWaitingBlocks.js","webpack:///./src/network/packets/waitingBlocks.js","webpack:///./src/network/socket.js","webpack:///./src/network/utils/bytesUtils.js","webpack:///./src/network/utils/reader.js","webpack:///./src/network/utils/writer.js","webpack:///./src/ui/animation.js","webpack:///./src/ui/objects/block.js","webpack:///./src/ui/objects/camera.js","webpack:///./src/ui/objects/player.js","webpack:///./src/ui/objects/point.js","webpack:///./src/ui/objects/rectangle.js","webpack:///./src/ui/utils.js","webpack:///./src/utils/math.js","webpack:///webpack/bootstrap","webpack:///webpack/runtime/compat get default export","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///./src/app.js"],"sourcesContent":["import Player from \"./ui/objects/player\";\n\nconst keyMapper = { //In Circle Way\n    ArrowUp: 1,\n    ArrowDown: 3,\n    ArrowLeft: 4,\n    ArrowRight: 2,\n}\n\nwindow.onkeyup = (e) => {\n    //console.log(keyMapper[e.key]);\n    const keyVal = keyMapper[e.key];\n    if(keyVal && window.client && window.client.player){\n        const dir = Player.mapControlsToDir(keyVal);\n        window.client.player.requestChangeDir(dir);\n    }\n};\n","Object.defineProperty(Array.prototype, 'getLast', {\n    get: function() {\n        if (this.length === 0) {\n            throw new Error(\"No elements in array\");\n        }\n        return this[this.length - 1];\n    }\n});\n\n\nObject.defineProperty(Array.prototype, 'first', {\n    get: function() {\n        if (this.length === 0) {\n            throw new Error(\"No elements in array\");\n        }\n        return this[0];\n    }\n});\n","import * as GameMath from './utils/math.js';\nimport * as GameUtils from './ui/utils.js';\nimport {calculate_pixel_ratio} from \"./ui/utils.js\";\nimport GameObjects from \"./gameObjects.js\"\nimport PingPacket from \"./network/packets/ping\";\n\n\nclass GameEngine {\n    constructor(fps) {\n        this.lastFrameTimeStamp = 0\n        this.currentFrameTimeStamp = 0\n        this.totalDeltaTimeCap = 0\n        this.fps = fps\n        this.deltaTime = 1000 / this.fps;\n        this.interpoatedDeltaTime = 1000 / this.fps;\n\n\n        this.timesCap = [0, 6.5, 16, 33, 49, 99];\n        this.currentCapIndex = 0;\n\n        this.processFrames = [];\n        this.missedFrames = [];\n\n\n        this.canvanQaulity = 1;\n\n\n        this.gameObjects = new GameObjects();\n\n        this.drawFunction = () => {\n        };\n    }\n\n    setDrawFunction(drawFunction) {\n        this.drawFunction = drawFunction;\n    }\n\n\n    getCap(cap) {\n        return this.timesCap[GameMath.clamp(cap, 0, this.timesCap.length - 1)];\n    }\n\n    checkIncreasingInFramesProcess() {\n        // This function checks if the game is running at the right speed.\n        // If the game is running too fast, it will decrease the currentCapIndex.\n        // if currentFrameTimeStamp < 90% of the currentCapIndex, then decrease the currentCapIndex.\n        if (this.currentFrameTimeStamp < GameMath.linearInterpolate(\n            this.getCap(this.currentCapIndex), this.getCap(this.currentCapIndex - 1),\n            0.9\n        )) {\n            this.processFrames.push(Date.now());\n\n            // If Draw More than 190 frames in 10 seconds, then remove the first frame.\n            while (this.processFrames.length > 190) {\n                if (Date.now() - this.processFrames[0] > 10_000) {\n                    this.processFrames.splice(0, 1)\n                } else {\n                    // if first frame happen in less than 10 seconds, decrease the currentCapIndex.\n                    this.currentCapIndex--;\n                    this.processFrames = [];\n                    this.currentCapIndex = GameMath.clamp(this.currentCapIndex, 0, this.timesCap.length - 1);\n                }\n            }\n        }\n    }\n\n    checkDecreaseInFramesProcess() {\n        // This function checks if the game is running at the right speed.\n        // If the game is running too slow, it will increase the currentCapIndex.\n        // if currentFrameTimeStamp > 5% of the currentCapIndex, then increase the currentCapIndex.\n        if (this.currentFrameTimeStamp > GameMath.linearInterpolate(\n            this.getCap(this.currentCapIndex), this.getCap(this.currentCapIndex + 1),\n            0.05\n        )) {\n            this.missedFrames.push(Date.now());\n            this.processFrames = [];\n            // If Draw Less than 5 frames in 5 seconds, then remove the first frame.\n            while (this.missedFrames.length > 5) {\n                if (Date.now() - this.missedFrames[0] > 5_000) {\n                    this.missedFrames.splice(0, 1)\n                } else {\n                    // if first frame happen in less than 5 seconds, increase the currentCapIndex.\n                    this.currentCapIndex++;\n                    this.missedFrames = [];\n                    this.currentCapIndex = GameMath.clamp(this.currentCapIndex, 0, this.timesCap.length - 1);\n                }\n            }\n        }\n    }\n\n\n    handleServerTiming(timeStamp) {\n        if (!window.client || !window.client.player)\n            return;\n        const myPlayer = window.client.player;\n        const maxWaitTimeForDisconnect = window.game.maxWaitingSocketTime;\n        const clientSideSetPosPassedTime = Date.now() - myPlayer.lastMyPostSetClientSendTime;\n        const lastConfirmationPassedTime = Date.now() - myPlayer.lastConfirmedTimeForPos;\n        const serverSideSetPosPassed = Date.now() - myPlayer.lastPosServerSentTime;\n\n        const timeTookToConfirmation = serverSideSetPosPassed - clientSideSetPosPassedTime;\n\n        // console.log(`Last Confirmation Passed Time: ${lastConfirmationPassedTime}ms`);\n        // console.log(`Time Took To Confirmation: ${timeTookToConfirmation}ms`);\n        if (lastConfirmationPassedTime > maxWaitTimeForDisconnect &&\n            timeTookToConfirmation > maxWaitTimeForDisconnect) {\n            console.log(\"Check Your Internet Connection\");\n\n        }else {\n\n        }\n\n        const maxPingTime = myPlayer.waitingForPing ? 1_0000: 5_000;\n        const pingPassedTime = Date.now() - myPlayer.lastPingTime;\n        if(pingPassedTime > maxPingTime) {\n            myPlayer.waitingForPing = true;\n            myPlayer.lastPingTime = Date.now();\n            const pingPacket = new PingPacket();\n            window.client.send(pingPacket);\n        }\n\n\n\n    }\n\n    loop(timeStamp) {\n        window.game.timeStamp = timeStamp;\n        this.currentFrameTimeStamp = timeStamp - this.lastFrameTimeStamp; // 16\n\n        if(this.currentFrameTimeStamp > this.interpoatedDeltaTime){\n            this.interpoatedDeltaTime = this.currentFrameTimeStamp;\n        }else\n        {\n            this.interpoatedDeltaTime = GameMath.linearInterpolate(this.interpoatedDeltaTime, this.currentFrameTimeStamp, 0.05);\n        }\n\n\n\n        this.checkIncreasingInFramesProcess();\n        this.checkDecreaseInFramesProcess();\n        this.deltaTime = this.currentFrameTimeStamp + this.totalDeltaTimeCap;\n        // console.log(this.deltaTime, this.gameObjects.blocks.length);\n        this.lastFrameTimeStamp = timeStamp;\n        if (this.deltaTime < this.getCap(this.currentCapIndex)) {\n            this.totalDeltaTimeCap += this.currentFrameTimeStamp;\n\n        } else {\n            this.totalDeltaTimeCap = 0;\n            this.drawFunction();\n        }\n\n\n        this.handleServerTiming(timeStamp);\n        window.requestAnimationFrame(this.loop.bind(this));\n    }\n\n\n    camTransform(ctx, changeSize = false) {\n        if (changeSize) {\n            this.scaleCanvas(ctx);\n        }\n\n        ctx.save();\n        const camera = window.camera;\n        camera.calZoom(ctx);\n\n\n    }\n\n    scaleCanvas(ctx, w = GameUtils.getWidth(),\n                h = GameUtils.getHeight()) {\n        let MAX_PIXEL_RATIO = calculate_pixel_ratio();\n        let drawingQuality = 1;\n        let c = ctx.canvas;\n        c.width = w * drawingQuality * MAX_PIXEL_RATIO;\n        c.height = h * drawingQuality * MAX_PIXEL_RATIO;\n        let styleRatio = 1;\n        c.style.width = w * styleRatio + \"px\";\n        c.style.height = h * styleRatio + \"px\";\n    }\n\n}\n\n\nexport default GameEngine;","import Block from './ui/objects/block.js';\n\nclass GameObjects {\n    constructor() {\n        this.players = {};\n        this.blocks = [];\n        this.myPlayer = null;\n        this.mapSize = 0;\n    }\n\n\n    /***\n     * Add Player To Game Objects\n     *  if player is already in the game objects return the player\n     *  if player is my player set it to my player\n     *  else set player to ready as it is already in the game\n     */\n    addPlayer(player) {\n        if (player.id in this.players)\n            return this.players[player.id];\n        if (player.isMyPlayer)\n            this.myPlayer = player;\n        else\n            player.isReady = true;\n\n        this.players[player.id] = player;\n        return player;\n    }\n\n\n    removePlayer(player) {\n        if (player.id in this.players)\n            delete this.players[player.id];\n    }\n\n    isPlayerExist(player) {\n        return player.id in this.players;\n    }\n\n    addBlock(block) {\n        return Block.getBlockAt(block.position, this.blocks);\n    }\n\n\n}\n\nexport default GameObjects;","import Point from \"./ui/objects/point.js\";\n\nconst globals = {\n    timeStamp: 0,\n    gameSpeed: 0.006,\n    viewPortRadius: 30,\n    maxZoom: 430,\n    maxBlocksNumber: 2500, //1100 50 * 50\n    usernameLength: 6,\n    maxWaitingSocketTime: 1_000,\n    drawingOffset: 10,\n    calDrawingOffset: (p) => {\n        return new Point(p.x * globals.drawingOffset, p.y * globals.drawingOffset);\n    }\n};\n\n\n\n\nwindow.game = {};\n// Adding to window object\nObject.entries(globals).forEach(([key, value]) => {\n    window.game[key] = value;\n});\n","import Socket from \"./socket.js\"\nimport Reader from \"./utils/reader.js\"\nimport PacketsDictionary from \"./packets/packets\";\nimport NamePacket from \"./packets/namePacket.js\";\n\nconst ConnectionStatus = {\n    CONNECTING: 0,\n    OPEN: 1,\n    CLOSING: 2,\n    CLOSED: 3\n};\n\nconst PlayerStatus = {\n    WAITING: -1,\n    CONNECTED: 0,\n    READY: 1,\n    PLAYING: 2,\n    DISCONNECTED: 3\n};\n\n\n\n\n\nclass Client {\n    constructor(server,onConnect, ) {\n        window.client = this;\n        this.server = server;\n        this.ws = new Socket(this.server, this);\n        this.ws.iniSocket();\n        this.onConnect = onConnect;\n\n\n        this.connectionStatus = ConnectionStatus.CONNECTING;\n        this.playerStatus = PlayerStatus.WAITING;\n        this.username = \"\";\n        this.player = null;\n\n\n    }\n\n\n    send(packet) {\n\n        // console.log(\"Sending Packet ->>>>>\" +packet.constructor.name);\n        this.ws.send(packet);\n    }\n\n    onReceive(messageEvent) {\n        if (typeof messageEvent.data !== \"object\")\n            return;\n\n        this.packetHandler(messageEvent.data);\n\n\n    }\n\n    onOpen(onOpenEvent) {\n        console.log(\"Connected to server\");\n        console.log(onOpenEvent);\n        this.connectionStatus = ConnectionStatus.OPEN;\n        this.playerStatus = PlayerStatus.CONNECTED;\n        this.onConnect(this);\n\n    }\n\n    onClose(onCloseEvent) {\n        console.log(\"OnClose to server\");\n        console.log(onCloseEvent);\n        this.connectionStatus = ConnectionStatus.CLOSED;\n    }\n\n    packetHandler(data) {\n        let x = new Uint8Array(data);\n        const reader = new Reader(x);\n        const packetSize = reader.readInt2();\n        const packetId = reader.readInt2();\n        const packetClass = PacketsDictionary[packetId];\n        const packet = packetClass.parsePacketData(packetSize, reader, packetClass);\n        packet.handleReceivedPacket(this);\n    }\n\n    setPlayerName(name) {\n        let p = new NamePacket(name);\n        this.send(p);\n    }\n\n}\n\nexport {ConnectionStatus, Client, PlayerStatus};","import Reader from './utils/reader.js';\nimport Writer from './utils/writer.js';\n\nclass Packet {\n    constructor() {\n        this.data = null;\n        this.packetId = -1;\n        this.packetSize = 0;\n        this.reader = null\n    }\n\n\n    setPacketData(data) {\n        this.data = data;\n    }\n\n\n    toHexString() {\n        if (this.reader === null)\n            throw new Error(\"Reader is null\");\n\n        return this.reader.toHexString();\n    }\n\n\n    parsePacket() {\n        throw new Error(\"Not implemented\");\n    }\n\n    static parsePacketData(packetSize, reader, packet) {\n        let p = new packet();\n        // console.log(\"Received Packet <-----: \" + p.constructor.name);\n\n        p.reader = reader;\n        p.data = reader.data;\n        p.packetSize = packetSize;\n        p.parsePacket();\n        return p;\n    }\n\n    handleReceivedPacket(client) {\n        throw new Error(\"Not implemented\");\n    }\n\n    finalize() {\n        throw new Error(\"Not implemented\");\n    }\n\n}\n\nexport default Packet;","import Packet from '../packet.js';\nimport Writer from '../utils/writer.js';\nimport Player from \"../../ui/objects/player.js\";\nimport {convertIntColorToHex} from \"../../ui/utils.js\";\nimport Point from \"../../ui/objects/point\";\n\n\nclass DirectionPacket extends Packet {\n\n    constructor(direction, position) {\n        super();\n        this.dir = direction;\n        this.packetId = 1006;\n        this.position = position;\n    }\n\n\n    // Handel Server Response\n    parsePacket() {\n    }\n\n    finalize() {\n        // Handle Server Request\n        // Send Empty Packet As Ask For Ready\n        const writer = new Writer(this.packetId);\n        writer.writeStringInBytes(this.dir);\n        writer.writeIntInBytes(this.position.x, 2);\n        writer.writeIntInBytes(this.position.y, 2);\n        return writer.finalize();\n    }\n\n\n    handleReceivedPacket(client) {\n    }\n}\n\nexport default DirectionPacket;","import Packet from \"../packet\";\nimport Reader from '../utils/reader.js';\nimport Writer from '../utils/writer.js';\nimport Rectangle from \"../../ui/objects/rectangle.js\";\nimport Point from \"../../ui/objects/point.js\";\nimport {convertIntColorToHex} from \"../../ui/utils.js\";\nimport Block from \"../../ui/objects/block\";\n\nclass FillAreaPacket extends Packet {\n    constructor() {\n        super();\n        this.packetId = 1003;\n        // Shape\n        this.rectangle = null;\n        this.width = 0;\n        this.height = 0;\n        this.x = 0;\n        this.y = 0;\n\n        // Colors\n        this.colorBrighter = 0;\n        this.colorDarker = 0;\n        this.colorSlightlyBrighter = 0\n        this.colorPattern = 0\n        this.colorPatternEdge = 0\n        this.playerId = 0;\n\n    }\n\n    finalize() {\n        // Handle Server Request\n        // Send Empty Packet As Ask For Ready\n        const writer = new Writer(this.packetId);\n        return writer.finalize();\n    }\n\n    parsePacket() {\n        const reader= this.reader;\n\n        this.x = reader.readInt2();\n        this.y = reader.readInt2();\n        this.width = reader.readInt2();\n        this.height = reader.readInt2();\n\n        this.playerId = reader.readInt4();\n        this.colorBrighter = convertIntColorToHex(reader.readInt4());\n        this.colorDarker = convertIntColorToHex(reader.readInt4());\n        this.colorSlightlyBrighter = convertIntColorToHex(reader.readInt4());\n        this.colorPattern = convertIntColorToHex(reader.readInt4());\n        this.colorPatternEdge = convertIntColorToHex(reader.readInt4());\n\n        this.rectangle = new Rectangle(new Point(this.x, this.y), new Point(this.x + this.width, this.y + this.height));\n\n\n    }\n\n    handleReceivedPacket(client) {\n        console.log(\"Received Fill Area Packet\");\n\n        const colorsWithId = {\n            brighter: this.colorBrighter,\n            darker: this.colorDarker,\n            slightlyBrighter: this.colorSlightlyBrighter,\n            pattern: this.colorPattern,\n            patternEdge: this.colorPatternEdge,\n            id: this.playerId\n        }\n        Block.convertRectToBlock(this.rectangle, colorsWithId,window.gameEngine.gameObjects.blocks,\n            window.gameEngine.gameObjects.myPlayer\n            );\n\n    }\n}\n\nexport default FillAreaPacket;","import Packet from '../packet.js';\nimport Reader from '../utils/reader.js';\nimport Writer from '../utils/writer.js';\nimport {PlayerStatus} from \"../client.js\"\nimport Ready from \"./ready\";\nimport Player  from \"../../ui/objects/player\";\nimport Point from \"../../ui/objects/point\";\n\nclass NamePacket extends Packet {\n\n    constructor(name) {\n        super();\n        this.name = name;\n        this.packetId = 1001;\n        this.isVerified = false;\n        this.userId = 0;\n    }\n\n\n    // Handel Server Response\n    parsePacket() {\n        const nameLength = this.reader.readInt2();\n        this.name = this.reader.readStringFromBytes(nameLength);\n        this.userId = this.reader.readInt4();\n        this.isVerified = this.reader.readInt1() === 1;\n\n    }\n\n    finalize() {\n        const writer = new Writer(this.packetId);\n        writer.writeStringInBytes(this.name);\n        writer.writeIntInBytes(this.isVerified ? 1 : 0, 1)\n        return writer.finalize();\n    }\n\n\n    handleReceivedPacket(client) {\n\n        if (this.isVerified) {\n\n            const player = new Player(new Point(0,0), this.userId);\n            player.isMyPlayer = true;\n\n            client.player = player;\n            client.isVerified = this.isVerified;\n            client.username = this.name;\n            client.playerStatus = PlayerStatus.READY;\n            window.gameEngine.gameObjects.addPlayer(player);\n\n            client.send(new Ready());\n        }else\n        {\n            //TODO Handle Not Verified Name\n        }\n\n    }\n}\n\nexport default NamePacket;","import NamePacket from \"./namePacket\";\nimport Ready from \"./ready\";\nimport FillAreaPacket from \"./fillArea\";\nimport PlayerStatePacket from \"./playerState\";\nimport WaitingBlocksPacket from \"./waitingBlocks\";\nimport DirectionPacket from \"./direction\";\nimport PingPacket from \"./ping\";\nimport PongPacket from \"./pong\";\nimport RequestWaitingBlockPacket from \"./requestWaitingBlocks\";\nimport PlayerRemovedPacket from \"./playerRemoved\";\nimport StopDrawingWaitingBlocksPacket from \"./stopDrawingWaitingBlocks\";\n\nconst PacketsDictionary = {\n    1001: NamePacket,\n    1004: PlayerStatePacket,\n    1002: Ready,\n    1003: FillAreaPacket,\n    1005: WaitingBlocksPacket,\n    1006: DirectionPacket,\n    1007: PingPacket,\n    1008: PongPacket,\n    1009: RequestWaitingBlockPacket,\n    1010: PlayerRemovedPacket,\n    1011: StopDrawingWaitingBlocksPacket,\n}\n\n\nexport default PacketsDictionary;","import Packet from '../packet.js';\nimport Writer from '../utils/writer.js';\nimport Player from \"../../ui/objects/player.js\";\nimport {convertIntColorToHex} from \"../../ui/utils.js\";\nimport Point from \"../../ui/objects/point\";\n\n\nclass PingPacket extends Packet {\n\n    constructor() {\n        super();\n        this.packetId = 1007;\n    }\n\n\n    // Handel Server Response\n    parsePacket() {\n\n    }\n\n    finalize() {\n        // Handle Server Request\n        const writer = new Writer(this.packetId);\n        return writer.finalize();\n    }\n\n\n    handleReceivedPacket(client) {\n    }\n}\n\nexport default PingPacket;","import Packet from '../packet.js';\nimport Writer from '../utils/writer.js';\nimport Player from \"../../ui/objects/player.js\";\nimport {convertIntColorToHex} from \"../../ui/utils.js\";\nimport Point from \"../../ui/objects/point\";\n\n\nclass PlayerRemovedPacket extends Packet {\n\n    constructor() {\n        super();\n        this.userId = null;\n        this.packetId = 1010;\n        this.player = null;\n\n    }\n\n\n    // Handel Server Response\n    parsePacket() {\n        this.userId = this.reader.readInt4();\n    }\n\n    finalize() {\n        // Handle Server Request\n        // Send Empty Packet As Ask For Ready\n        const writer = new Writer(this.packetId);\n        return writer.finalize();\n    }\n\n\n    handleReceivedPacket(client) {\n        const player = window.gameEngine.gameObjects.players[this.userId];\n        if(player)\n            window.gameEngine.gameObjects.removePlayer(player);\n\n    }\n}\n\nexport default PlayerRemovedPacket;","import Packet from '../packet.js';\nimport Writer from '../utils/writer.js';\nimport Player from \"../../ui/objects/player.js\";\nimport {convertIntColorToHex} from \"../../ui/utils.js\";\nimport Point from \"../../ui/objects/point\";\n\n\nclass PlayerStatePacket extends Packet {\n\n    constructor(userId, mapSize) {\n        super();\n        this.userId = userId;\n        this.packetId = 1004;\n        this.player = null;\n\n    }\n\n\n    // Handel Server Response\n    parsePacket() {\n        const reader = this.reader;\n        this.userId = reader.readInt4();\n        this.playerName = reader.readString();\n\n        this.playerX = reader.readInt2();\n        this.playerY = reader.readInt2();\n        this.direction = reader.readString();\n\n\n        // Colors\n        this.colorBrighter = convertIntColorToHex(reader.readInt4());\n        this.colorDarker = convertIntColorToHex(reader.readInt4());\n        this.colorSlightlyBrighter = convertIntColorToHex(reader.readInt4());\n        this.colorPattern = convertIntColorToHex(reader.readInt4());\n        this.colorPatternEdge = convertIntColorToHex(reader.readInt4());\n\n    }\n\n    finalize() {\n        // Handle Server Request\n        // Send Empty Packet As Ask For Ready\n        const writer = new Writer(this.packetId);\n        return writer.finalize();\n    }\n\n\n    handleReceivedPacket(client) {\n        console.log(\"PlayerState Ready Packet\");\n\n        const myPlayer = client.player;\n\n        let player = new Player(new Point(0, 0), this.userId);\n        player = window.gameEngine.gameObjects.addPlayer(player);\n\n\n        player.name = this.playerName;\n        player.colorBrighter = this.colorBrighter;\n        player.colorDarker = this.colorDarker;\n        player.colorSlightlyBrighter = this.colorSlightlyBrighter;\n        player.colorPattern = this.colorPattern;\n        player.colorPatternEdge = this.colorPatternEdge;\n\n\n\n\n        // When Receiving Player State\n        // Next Frame Move Relative To Server Pos\n        player.hasReceivedPosition = true;\n        player.moveRelativeToServerPosNextFrame = true;\n        player.lastServerPosSentTime = Date.now();\n\n        // current player consider that his last position has been confirmed\n        myPlayer.lastPosHasBeenConfirmed = true;\n\n\n        let offset = player.calMoveOffset();\n        let newPos = new Point(this.playerX, this.playerY);\n        let newPosOffset = newPos.clone();\n        let newDir = this.direction;\n\n        newPosOffset = Player.movePlayer(newPosOffset, newDir, offset);\n        let clientServerNeedsSync = true;\n\n\n        if (player.isMyPlayer) {\n            player.lastPosServerSentTime = Date.now();\n\n            // Check If Server Synced With Client\n            // To Draw This Movement or Ignore It\n            // if server predict the same movement\n            // or the movement is to close to server\n            clientServerNeedsSync = player.checkClientMovementSyncedWithServer(newDir\n                , newPosOffset, newPos);\n\n            if (clientServerNeedsSync) {\n                /***\n                 Here We Found That Server and Client not Synced\n                 So We Need To Sync Them\n                 1- Change Player Direction\n                 2- Change Player Position\n                 3- Request Waiting Blocks From Server\n                 4- Clear Send Dir Queue\n                 */\n                player.changeCurrentDir(newDir, newPos, false, false);\n                player.requestWaitingBlocks();\n                player.sendDirQueue = [];\n            }\n\n            player.serverPos = newPosOffset.clone();\n            player.serverDir = newDir;\n\n            player.removeBlocksOutsideCamera();\n        } else {\n            player.updatePlayerDirection(newDir);\n        }\n\n        if (clientServerNeedsSync) {\n            player.position = newPosOffset.clone();\n            player.addWaitingBlocks(newPos);\n        }\n\n        //Start To Handel Draw Position\n        if (!player.drawPosSet) {\n            // if we don't draw this player before set draw position\n            player.drawPosSet = true;\n            player.drawPosition = player.position.clone();\n        }\n\n    }\n}\n\nexport default PlayerStatePacket;","import Packet from '../packet.js';\nimport Writer from '../utils/writer.js';\nimport Player from \"../../ui/objects/player.js\";\nimport {convertIntColorToHex} from \"../../ui/utils.js\";\nimport Point from \"../../ui/objects/point\";\nimport * as GameMath from \"../../utils/math\";\n\nclass PongPacket extends Packet {\n\n    constructor() {\n        super();\n        this.packetId = 1008;\n    }\n\n\n    // Handel Server Response\n     parsePacket() {\n\n    }\n\n    finalize() {\n        // Handle Server Request\n        const writer = new Writer(this.packetId);\n        return writer.finalize();\n    }\n\n\n    handleReceivedPacket(client) {\n        const myPlayer = client.player;\n        const ping = Date.now() - myPlayer.lastPingTime;\n        const currentPingDiff = Math.abs(ping - myPlayer.severLastPing);\n        myPlayer.serverPingDiff = Math.max(myPlayer.serverPingDiff, currentPingDiff);\n        myPlayer.serverPingDiff = GameMath.linearInterpolate(currentPingDiff, myPlayer.serverPingDiff, 0.5);\n        myPlayer.serverAvgPing = GameMath.linearInterpolate(myPlayer.serverAvgPing, ping, 0.5);\n        myPlayer.severLastPing = ping;\n        myPlayer.lastPingTime = Date.now();\n        myPlayer.waitingForPing = false;\n    }\n}\n\nexport default PongPacket;","import Packet from '../packet.js';\nimport Writer from '../utils/writer.js';\nimport Player from \"../../ui/objects/player.js\";\nimport {convertIntColorToHex} from \"../../ui/utils.js\";\nimport Point from \"../../ui/objects/point\";\n\n\nclass Ready extends Packet {\n\n    constructor(userId, mapSize) {\n        super();\n        this.userId = userId;\n        this.packetId = 1002;\n        this.mapSize = mapSize;\n        this.playerName = \"\";\n        this.playerX = 0;\n        this.playerY = 0;\n        this.direction = 0;\n\n\n        // Colors\n        this.colorBrighter = 0;\n        this.colorDarker = 0;\n        this.colorSlightlyBrighter = 0\n        this.colorPattern = 0\n        this.colorPatternEdge = 0\n    }\n\n\n    // Handel Server Response\n\n    parsePacket() {\n        const reader = this.reader;\n\n        this.userId = reader.readInt4();\n        this.mapSize = reader.readInt2();\n        this.playerName = reader.readString();\n\n        this.playerX = reader.readInt2();\n        this.playerY = reader.readInt2();\n        this.direction = reader.readString();\n\n\n        // Colors\n        this.colorBrighter = convertIntColorToHex(reader.readInt4());\n        this.colorDarker = convertIntColorToHex(reader.readInt4());\n        this.colorSlightlyBrighter = convertIntColorToHex(reader.readInt4());\n        this.colorPattern = convertIntColorToHex(reader.readInt4());\n        this.colorPatternEdge = convertIntColorToHex(reader.readInt4());\n    }\n\n    finalize() {\n        // Handle Server Request\n        // Send Empty Packet As Ask For Ready\n        const writer = new Writer(this.packetId);\n        return writer.finalize();\n    }\n\n\n    handleReceivedPacket(client) {\n        console.log(\"Received Ready Packet\");\n        const player = client.player;\n\n        player.name = this.playerName;\n        player.colorBrighter = this.colorBrighter;\n        player.colorDarker = this.colorDarker;\n        player.colorSlightlyBrighter = this.colorSlightlyBrighter;\n        player.colorPattern = this.colorPattern;\n        player.colorPatternEdge = this.colorPatternEdge;\n        window.gameEngine.gameObjects.mapSize = this.mapSize;\n        player.isReady = true;\n\n\n    }\n}\n\nexport default Ready;","import Packet from '../packet.js';\nimport Writer from '../utils/writer.js';\n\nclass RequestWaitingBlockPacket extends Packet {\n\n    constructor() {\n        super();\n        this.packetId = 1009;\n\n\n    }\n\n    // Handel Server Response\n     parsePacket() {\n    }\n\n    finalize() {\n        // Handle Server Request\n        // Send Empty Packet As Ask For Ready\n        const writer = new Writer(this.packetId);\n        return writer.finalize();\n    }\n\n    handleReceivedPacket(client) {\n\n    }\n}\n\nexport default RequestWaitingBlockPacket;","import Packet from '../packet.js';\nimport Writer from '../utils/writer.js';\nimport Point from \"../../ui/objects/point\";\n\n\nclass StopDrawingWaitingBlocksPacket extends Packet {\n\n    constructor() {\n        super();\n        this.packetId = 1011;\n        this.player = null;\n        this.userId = null;\n        this.lastBlock = null;\n\n    }\n\n\n    // Handel Server Response\n    parsePacket() {\n        this.userId = this.reader.readInt4();\n        const vec = new Point(this.reader.readInt2(), this.reader.readInt2());\n        this.lastBlock = vec;\n\n    }\n\n    finalize() {\n        // Handle Server Request\n        // Send Empty Packet As Ask For Ready\n        const writer = new Writer(this.packetId);\n        return writer.finalize();\n    }\n\n\n    handleReceivedPacket(client) {\n        const playerList = window.gameEngine.gameObjects.players;\n        let player = null;\n        if (this.userId in playerList) {\n            player = playerList[this.userId];\n        } else {\n            throw new Error(\"Player Not Found We Need To Send Player Colors\");\n        }\n\n\n\n        if (player.waitingBlocks.length > 0) {\n            const playerWaitingBlocks = player.waitingBlocks.getLast.blocks;\n            if (playerWaitingBlocks.length > 0) {\n                playerWaitingBlocks.push(this.lastBlock);\n            }\n        }\n\n\n        // if player received to stop drawing waiting blocks request is sent to server\n        // we need to skip the response\n        if (player.isMyPlayer && player.isGettingWaitingBlocks) {\n            player.skipGettingWaitingBlocksRespose = true;\n        }\n\n        player.waitingBlocks.push({\n            vanishTimer: 0,\n            blocks: []\n        });\n\n\n    }\n}\n\nexport default StopDrawingWaitingBlocksPacket;","import Packet from '../packet.js';\nimport Writer from '../utils/writer.js';\nimport Player from \"../../ui/objects/player.js\";\nimport {convertIntColorToHex} from \"../../ui/utils.js\";\nimport Point from \"../../ui/objects/point\";\n\n\nclass WaitingBlocksPacket extends Packet {\n\n    constructor() {\n        super();\n        this.packetId = 1005;\n        this.player = null;\n        this.userId = null;\n        this.blocks = [];\n\n    }\n\n\n    // Handel Server Response\n    parsePacket() {\n        const reader = this.reader;\n        this.userId = reader.readInt4();\n        const blocksCount = reader.readInt2();\n        for (let i = 0; i < blocksCount; i++) {\n            const vec = new Point(reader.readInt2(), reader.readInt2());\n            this.blocks.push(vec);\n        }\n    }\n\n    finalize() {\n        // Handle Server Request\n        // Send Empty Packet As Ask For Ready\n        const writer = new Writer(this.packetId);\n        return writer.finalize();\n    }\n\n\n    handleReceivedPacket(client) {\n        const playerList = window.gameEngine.gameObjects.players;\n        let player = null;\n        if (this.userId in playerList) {\n            player = playerList[this.userId];\n        } else {\n            throw new Error(\"Player Not Found We Need To Send Player Colors\");\n        }\n\n\n        let replaceWaitingBlocks = false;\n        if (player.isMyPlayer) {\n\n\n            // some cases we need to skip the response\n            if (player.skipGettingWaitingBlocksRespose) {\n                player.skipGettingWaitingBlocksRespose = false;\n                player.waitingPushedDuringReceiving = [];\n            } else {\n\n                // If Player Requesting Waiting Blocks vai RequestWaitingBlocks Packet\n                // the RequestWaitingBlocks could happen if we found server and client blocks are not synced\n                // in Player State Packet\n                if (player.isGettingWaitingBlocks) {\n                    player.isGettingWaitingBlocks = false;\n\n                    // Player Requesting Waiting Blocks From Server So We Need To Replace The Waiting Blocks\n                    replaceWaitingBlocks = true;\n\n\n                    // Push Player Movement During Receiving Waiting Blocks\n                    for (let i = 0; i < player.waitingPushedDuringReceiving.length; i++) {\n                        const vec = player.waitingPushedDuringReceiving[i];\n                        this.blocks.push(vec);\n                    }\n\n                    player.waitingPushedDuringReceiving = [];\n                }\n\n\n\n                // If Player Waiting Blocks Are Empty We Need To Request Waiting Blocks\n                // possible that player received stop drawing blocks\n                // possible that initial waiting blocks are empty game just started\n\n                if (player.waitingBlocks.length > 0) {\n                    const lastBlock = player.waitingBlocks.getLast;\n                    if (lastBlock.blocks.length <= 0 && this.blocks.length > 0) {\n                        // this call will cause to replace the waiting blocks with the new blocks coming from server\n                        player.requestWaitingBlocks();\n\n                    }\n                }\n            }\n        }\n\n\n        if (replaceWaitingBlocks) {\n            if (player.waitingBlocks.length > 0) {\n                const lastBlock = player.waitingBlocks.getLast;\n                lastBlock.blocks = [...this.blocks];\n                lastBlock.vanishTimer = 0;\n            } else {\n                replaceWaitingBlocks = false;\n            }\n        }\n\n        if (!replaceWaitingBlocks) {\n            player.waitingBlocks.push({\n                vanishTimer: 0,\n                blocks: [...this.blocks]\n            });\n        }\n\n        console.log(\"Waiting Blocks\", [...player.waitingBlocks]);\n\n    }\n}\n\nexport default WaitingBlocksPacket;","class Socket{\n    constructor(server,client) {\n        this.server = server;\n        this.onReceive = client.onReceive.bind(client);\n        this.onOpen = client.onOpen.bind(client);\n        this.onClose = client.onClose.bind(client);\n        this.ws = null;\n    }\n\n    iniSocket() {\n        this.ws = new WebSocket(this.server);\n        let ws = this.ws;\n        ws.binaryType = \"arraybuffer\";\n        ws.onopen = this.onOpen;\n        ws.onmessage = this.onReceive;\n        ws.onclose = this.onClose;\n    }\n\n    send(packet) {\n        this.ws.send(packet.finalize());\n    }\n\n}\n\nexport default Socket;","const intToBytes = (value, byteorder = 'little', signed = false, numBytes = 4) => {\n    const littleEndian = (byteorder === 'little');\n    const bytes = new Uint8Array(numBytes);\n    const view = new DataView(bytes.buffer);\n\n    if (signed && value < 0) {\n        // Convert negative value to 2's complement representation\n        value = (1 << (8 * numBytes)) + value;\n    }\n\n    for (let i = 0; i < numBytes; i++) {\n        const shift = littleEndian ? i * 8 : (numBytes - 1 - i) * 8;\n        view.setUint8(i, (value >> shift) & 0xFF);\n    }\n\n    return bytes;\n}\nconst bytesToInt = (bytes, byteorder = 'little', signed = false) => {\n    const view = new DataView(bytes.buffer);\n    const littleEndian = (byteorder === 'little');\n\n    if (bytes.length <= 0 || bytes.length > 8) {\n        throw new Error('Unsupported number of bytes');\n    }\n    let value = 0;\n\n    for (let i = 0; i < bytes.length; i++) {\n        const shift = littleEndian ? i * 8 : (bytes.length - 1 - i) * 8;\n        value |= view.getUint8(i) << shift;\n    }\n    if (signed) {\n        const signBit = 1 << (8 * bytes.length - 1);\n        if (value & signBit) {\n            value = value - (signBit << 1);\n        }\n    }\n    return value;\n}\n\n\nconst toHexString = (data) => {\n    return Array.from(data)\n        .map(byte => '0x' + byte.toString(16).padStart(2, '0'))\n        .join(' ');\n}\n\nexport {intToBytes, bytesToInt,toHexString};","import {intToBytes, bytesToInt, toHexString} from './bytesUtils.js';\n\n\nclass Reader {\n    constructor(data) {\n        this.data = data;\n        this.position = 0;\n    }\n\n    readIntFromBytes(bytesNumber = 2) {\n        const bytes = this.data.slice(this.position, this.position + bytesNumber);\n        this.position += bytesNumber;\n        return bytesToInt(bytes, 'little', false);\n    }\n\n    readStringFromBytes(stringLength) {\n        const bytes = this.data.slice(this.position, this.position + stringLength);\n        this.position += stringLength;\n        return new TextDecoder().decode(bytes);\n    }\n\n    readString() {\n        const stringLength = this.readInt2();\n        return this.readStringFromBytes(stringLength);\n    }\n\n\n    readInt1() {\n        return this.readIntFromBytes(1);\n    }\n    readInt4() {\n        return this.readIntFromBytes(4);\n    }\n    readInt2() {\n        return this.readIntFromBytes(2);\n    }\n    readInt8() {\n        return this.readIntFromBytes(8);\n    }\n    readInt16() {\n        return this.readIntFromBytes(16);\n    }\n    readInt32() {\n        return this.readIntFromBytes(32);\n    }\n\n\n    toHexString()\n    {\n        return toHexString(this.data);\n    }\n\n}\n\nexport default Reader;","import {intToBytes, bytesToInt, toHexString} from './bytesUtils.js';\n\nclass Writer {\n    // Infinity\n    constructor(packetId = -1) {\n        this.packetSize = 20;\n        this.packetId = packetId;\n\n        this.data = new Uint8Array(this.packetSize);\n        this.position = 0;\n        this.setPacketId();\n    }\n\n    setPacketId() {\n        this.position = 2;\n        this.writeIntInBytes(this.packetId);\n        this.updatePacketSize()\n\n    }\n\n    updatePacketSize() {\n        this.packetSize = this.position;\n        const currentOffset = this.position;\n        this.position = 0;\n        const b = intToBytes(this.packetSize, 'little', false, 2);\n        this.data.set(b, this.position);\n        this.position = currentOffset;\n    }\n\n    writeIntInBytes(number, bytesNumber = 2) {\n        let bytes = intToBytes(number, 'little', false, bytesNumber);\n        this.ensureCapacity(bytesNumber);\n        this.data.set(bytes, this.position);\n        this.position += bytesNumber;\n        this.updatePacketSize();\n    }\n\n\n    writeStringInBytes(string) {\n        let stringLength = string.length;\n        this.writeIntInBytes(stringLength, 2);\n        let bytes = new TextEncoder().encode(string);\n        this.ensureCapacity(stringLength);\n        this.data.set(bytes, this.position);\n        this.position += stringLength;\n        this.updatePacketSize();\n    }\n\n    ensureCapacity(requiredSize) {\n\n        if (this.position + requiredSize > this.data.length) {\n            const newSize = requiredSize + (this.data.length) * 2;\n            const newData = new Uint8Array(newSize);\n            newData.set(this.data);\n            this.data = newData;\n        }\n\n    }\n\n    finalize() {\n        return this.data.slice(0, this.position);\n    }\n\n    toHexString() {\n        return toHexString(this.finalize());\n    }\n\n\n}\n\nexport default Writer;","class Animation {\n    constructor(startValue, endValue, duration) {\n        this.startValue = startValue;\n        this.endValue = endValue;\n        this.duration = duration;\n        this.progress = 0; // Ranges from 0 to 1\n        this.direction = 0; // 0 for idle, 1 for forward, -1 for backward\n        this.delay = 0;\n    }\n\n    update(deltaTime) {\n        // Handle the delay before starting the animation\n        if (this.delay > 0) {\n            this.delay -= deltaTime;\n            return;\n        }\n\n        if (this.direction === 0) return; // If idle, do nothing\n\n        this.progress += (deltaTime * this.duration) * this.direction;\n\n        if (this.progress >= 1) {\n            this.progress = 1;\n            this.direction = 0; // Stop the animation\n        } else if (this.progress <= 0) {\n            this.progress = 0;\n            this.direction = 1; // Stop the animation\n        }\n    }\n\n    setForward() {\n        this.direction = 1;\n    }\n\n    setBackward() {\n        this.direction = -1;\n    }\n\n    isAnimating() {\n        return this.direction !== 0 || this.delay > 0;\n    }\n\n    getProgress() {\n        return this.progress;\n    }\n\n    completeAndStop() {\n        this.progress = 1;\n        this.direction = 0;\n    }\n\n    isGoingForward() {\n        return this.direction === 1;\n    }\n    isGoingBackward() {\n        return this.direction === -1;\n    }\n\n    isIdle() {\n        return this.direction === 0;\n    }\n\n    isComplete() {\n        return this.progress === 1;\n    }\n}\nexport default Animation;","import Point from \"./point.js\";\nimport * as GameMath from \"../../utils/math.js\";\nimport * as GameUtils from \"../utils.js\";\nimport Animation from \"../animation.js\";\n\nclass Block {\n    constructor(p) {\n        this.position = p\n\n        this.currentBlock = -1;\n        this.nextBlock = -1;\n        this.colorsWithId = null;\n        this.lastSetTime = Date.now()\n        this.animation = new Animation(0, 1, 0.003);\n\n    }\n\n\n    setBlockId(id, delay) {\n        this.lastSetTime = Date.now();\n\n        // If there is no delay for the animation\n        if (!delay) {\n            this.currentBlock = this.nextBlock = id;\n            this.animation.completeAndStop();\n        } else {\n\n            // Set the delay\n            this.animation.delay = delay;\n\n            let isCurrentBlock = id === this.currentBlock;\n            let isNextBlock = id === this.nextBlock;\n\n\n            if (isCurrentBlock && isNextBlock) {\n                // If the current block is the same as the next block\n                // Then we don't need to do anything\n                if (this.animation.isGoingBackward()) {\n                    this.animation.setForward();\n                }\n            } else if (!isCurrentBlock && !isNextBlock) {\n                // if we need to change the block\n                // then we need to set the next block to the id\n                this.nextBlock = id;\n                this.animation.setBackward();\n            }\n\n                // this two cases can happen\n            // during the animation new block is set\n            else if (isCurrentBlock && !isNextBlock) {\n                // cancel the animation and set the next block to the id\n                this.nextBlock = this.currentBlock;\n                this.animation.setForward()\n            } else if (!isCurrentBlock && isNextBlock) {\n                // reverse the animation to set the current block to the id of next block\n                // in handleAnimation we will set the current block to the next block\n                if (this.animation.isGoingForward()) this.animation.setBackward()\n            }\n        }\n\n    }\n\n    static getBlockAt(p, blocks) {\n        for (let block of blocks) {\n            if (block.position.equals(p)) {\n                return block;\n            }\n        }\n        let block = new Block(p);\n        blocks.push(block);\n        return block;\n\n    }\n\n    handleAnimation() {\n        this.animation.update(window.gameEngine.deltaTime);\n        const progress = this.animation.getProgress();\n        if (progress <= 0) {\n            this.currentBlock = this.nextBlock;\n            return false;\n        }\n        return true;\n    }\n\n    calBlockGap(position, size) {\n        return new Point(position.x * size, position.y * size);\n    }\n\n\n    drawBorderBlock(ctx, color, size) {\n        if (this.currentBlock !== 0) return;\n\n        ctx.fillStyle = color;\n        // Calculate the new position Base Of the size\n        const newP = this.calBlockGap(this.position, size);\n        ctx.fillRect(newP.x, newP.y, size, size);\n    }\n\n    drawEmptyBlock(ctx, darkColor, brightColor, size) {\n        if (this.currentBlock !== 1) return;\n\n\n        const sizeFactor = 10 / size;\n        const newS = size * sizeFactor; // 10\n        let animProgress = 0;\n\n        const newP = this.calBlockGap(this.position, newS);\n        const spacingTwenty = GameMath.calPercentage(newS, 0.2);\n        const spacingTen = GameMath.calPercentage(newS, 0.1); // 1\n        const spacingNinty = GameMath.calPercentage(newS, 0.9);\n\n\n        /////////////////////// SHADOW ////////////////////////\n        if (this.animation.progress > .8) {\n            GameUtils.drawInCtxRec(ctx, newP, size, darkColor, spacingTwenty);\n        }\n\n        ctx.fillStyle = brightColor;\n        if (this.animation.progress === 1) {\n            GameUtils.drawInCtxRec(ctx, newP, size, brightColor, spacingTen);\n        } else if (this.animation.progress < .4) {\n            animProgress = this.animation.progress * 2.5;\n            ctx.beginPath();\n            ctx.moveTo(newP.x + spacingTwenty, newP.y + GameMath.linearInterpolate(spacingNinty, spacingTwenty, animProgress));\n            ctx.lineTo(newP.x + spacingTwenty, newP.y + spacingNinty);\n            ctx.lineTo(newP.x + GameMath.linearInterpolate(spacingTwenty, spacingNinty, animProgress), newP.y + spacingNinty);\n            ctx.fill();\n        } else if (this.animation.progress < 0.8) {\n            animProgress = this.animation.progress * 2.5 - 1;\n            ctx.beginPath();\n            ctx.moveTo(newP.x + spacingTwenty, newP.y + spacingTwenty);\n            ctx.lineTo(newP.x + spacingTwenty, newP.y + 9);\n            ctx.lineTo(newP.x + spacingNinty, newP.y + spacingNinty);\n            ctx.lineTo(newP.x + spacingNinty, newP.y + GameMath.linearInterpolate(spacingNinty, spacingTwenty, animProgress));\n            ctx.lineTo(newP.x + GameMath.linearInterpolate(spacingTwenty, spacingNinty, animProgress), newP.y + spacingTwenty);\n            ctx.fill();\n        } else {\n\n            animProgress = this.animation.progress * 5 - 4;\n            GameUtils.drawInCtxRec(ctx, newP, size, brightColor, GameMath.linearInterpolate(2, 1, animProgress));\n        }\n    }\n\n    drawRegularBlock(ctx, darkColor, brightColor, size) {\n\n\n        if (this.currentBlock < 2) return;\n\n        if (this.colorsWithId === null) {\n            return;\n        }\n\n\n        let bcolor = this.colorsWithId.pattern;\n        let dcolor = this.colorsWithId.patternEdge;\n\n\n        const sizeFactor = 10 / size;\n        const newS = size * sizeFactor; // 10\n        let animProgress = 0;\n\n        const newP = this.calBlockGap(this.position, newS);\n        const spacingTwenty = GameMath.calPercentage(newS, 0.2);\n        const spacingTen = GameMath.calPercentage(newS, 0.1); // 1\n        const spacingNinty = GameMath.calPercentage(newS, 0.9);\n\n        if (this.animation.progress > 0.8) {\n            ctx.fillStyle = dcolor;\n            ctx.fillRect(newP.x + spacingTen, newP.y + spacingTen, size, size);\n        }\n\n\n        ctx.fillStyle = bcolor;\n        if (this.animation.progress === 1) {\n            GameUtils.drawInCtxRec(ctx, newP, size, bcolor, spacingTen);\n        } else if (this.animation.progress < .4) {\n            animProgress = this.animation.progress * 2.5;\n            ctx.beginPath();\n            ctx.moveTo(newP.x + spacingTen, newP.y + GameMath.linearInterpolate(newS, spacingTen, animProgress));\n            ctx.lineTo(newP.x + spacingTen, newP.y + newS);\n            ctx.lineTo(newP.x + GameMath.linearInterpolate(spacingTen, newS, animProgress), newP.y + newS);\n            ctx.fill();\n        } else if (this.animation.progress < 0.8) {\n            animProgress = this.animation.progress * 2.5 - 1;\n            ctx.beginPath();\n            ctx.moveTo(newP.x + spacingTen, newP.y + spacingTen);\n            ctx.lineTo(newP.x + spacingTen, newP.y + newS);\n            ctx.lineTo(newP.x + newS, newP.y + newS);\n            ctx.lineTo(newP.x + newS, newP.y + GameMath.linearInterpolate(newS, spacingTen, animProgress));\n            ctx.lineTo(newP.x + GameMath.linearInterpolate(spacingTen, newS, animProgress), newP.y + spacingTen);\n            ctx.fill();\n        } else {\n\n            animProgress = this.animation.progress * 5 - 4;\n            GameUtils.drawInCtxRec(ctx, newP, size, bcolor, GameMath.linearInterpolate(1, 0, animProgress));\n        }\n\n    }\n\n    draw(ctx, checkViewport) {\n        if (checkViewport && window.camera.checkObjectInCamera(this.position)) {\n            console.log(\"not in camera\");\n            return;\n        }\n\n        let canDraw = this.handleAnimation();\n        if (!canDraw) {\n            return;\n        }\n\n        this.drawBorderBlock(ctx, \"#420707\", 10);\n        this.drawEmptyBlock(ctx, \"#2d2926\", \"#4e463f\", 7);\n        this.drawRegularBlock(ctx, \"#2d2926\", \"#4e463f\", 9);\n\n    }\n\n\n    static convertRectToBlock(rect, colorsWithId, listOfBlocks, myPlayer) {\n        const viewPortRadius = window.game.viewPortRadius;\n\n        if (myPlayer) {\n            rect.min.x = Math.max(rect.min.x, Math.round(myPlayer.position.x - viewPortRadius));\n            rect.min.y = Math.max(rect.min.y, Math.round(myPlayer.position.y - viewPortRadius));\n\n            rect.max.x = Math.min(rect.max.x, Math.round(myPlayer.position.x + viewPortRadius));\n            rect.max.y = Math.min(rect.max.y, Math.round(myPlayer.position.y + viewPortRadius));\n        }\n\n        for (let {x, y} of rect.for_each()) {\n            let block = Block.getBlockAt(new Point(x, y), listOfBlocks);\n            block.colorsWithId = colorsWithId;\n            block.setBlockId(colorsWithId.id, Math.random() * 400);\n        }\n\n    }\n\n}\n\n\nexport default Block;","import Point from \"./point.js\";\nimport Rectangle from \"./rectangle.js\";\nimport * as GameUtils from \"../utils.js\";\nimport * as GameMath from \"../../utils/math.js\";\n\nclass Camera {\n    constructor() {\n        this.zoom = 5;\n        this.camPosition = new Point(0, 0);\n        this.camRotationOffset = 0;\n        this.camPositionOffset = new Point(0, 0);\n        this.camPrevPosition = new Point(0, 0);\n\n        this.camPosSet = false;\n\n        this.camShakeBuffer = [];\n    }\n\n\n    // TODO ADD VIEWPORT RADIUS\n    checkObjectInCamera(point) {\n        return (\n            point.x < this.camPosition.x - window.game.viewPortRadius ||\n            point.x > this.camPosition.x + window.game.viewPortRadius ||\n            point.y < this.camPosition.y - window.game.viewPortRadius ||\n            point.y > this.camPosition.y + window.game.viewPortRadius\n        )\n    }\n\n    shakeCamera(p, rotate = true) {\n        this.camShakeBuffer.push([\n            p, 0, !!rotate\n        ]);\n    }\n\n    shakeCameraDirection(dir, amount = 6, rotate = true) {\n        let x, y = 0;\n        switch (dir) {\n            case 0:\n                x = amount;\n                break;\n            case 1:\n                y = amount;\n                break;\n            case 2:\n                x = -amount;\n                break;\n            case 3:\n                y = -amount;\n                break;\n        }\n        this.shakeCamera(new Point(x, y), rotate);\n    }\n\n    calCameraOffset() {\n        for (let i = this.camShakeBuffer.length - 1; i >= 0; i--) {\n            let shake = this.camShakeBuffer[i];\n            shake[1] = window.gameEngine.deltaTime * 0.003;\n            let shakeTime = shake[1];\n            let shakeTime2 = 0;\n            let shakeTime3 = 0;\n            if (shakeTime < 1) {\n                shakeTime2 = GameUtils.ease.out(shakeTime);\n                shakeTime3 = GameUtils.ease.inout(shakeTime);\n\n            } else if (shakeTime < 8) {\n                shakeTime2 = GameUtils.ease.inout(GameMath.inverseLinearInterpolate(8, 1, shakeTime));\n                shakeTime3 = GameUtils.ease.in(GameMath.inverseLinearInterpolate(8, 1, shakeTime));\n            } else {\n                this.camShakeBuffer.splice(i, 1);\n            }\n            this.camPositionOffset.x += shake[0].x * shakeTime2;\n            this.camPositionOffset.y += shake[0].y * shakeTime2;\n\n            this.camPositionOffset.x += shake[0] * Math.cos(shakeTime * 8) * 0.04 * shakeTime3;\n            this.camPositionOffset.y += shake[0] * Math.cos(shakeTime * 7) * 0.04 * shakeTime3;\n            if (shake[2]) {\n                this.camRotationOffset += Math.cos(shakeTime * 9) * 0.003 * shakeTime3;\n            }\n            console.log(this.camShakeBuffer.length);\n        }\n\n        let limit = 80;\n        let x = this.camPositionOffset.x;\n        let y = this.camPositionOffset.y;\n        x /= limit;\n        y /= limit;\n        x = GameMath.smoothLimit(x);\n        y = GameMath.smoothLimit(y);\n        x *= limit;\n        y *= limit;\n        this.camPositionOffset.x = x;\n        this.camPositionOffset.y = y;\n\n    }\n\n    calZoom(ctx) {\n        let maxPixelRatio = GameUtils.calculate_pixel_ratio();\n        let quality = 1;\n        const canvas = window.game.canvas;\n\n\n        if (ctx.canvas === canvas || true) {\n            const maxDimension = Math.max(canvas.width, canvas.height);\n            const zoomEdge = maxDimension / window.game.maxZoom;\n            const screenPixels = canvas.width * canvas.height;\n            const blockPixels = screenPixels / window.game.maxBlocksNumber;\n            const zoomBlocks = Math.sqrt(blockPixels) / 10;\n            this.zoom = Math.max(zoomEdge, zoomBlocks);\n            ctx.translate(window.game.canvas.width / 2, window.game.canvas.height / 2);\n\n            ctx.rotate(this.camRotationOffset);\n            ctx.scale(this.zoom, this.zoom);\n            ctx.translate(-this.camPrevPosition.x * 10 - this.camPositionOffset.x, -this.camPrevPosition.y * 10 - this.camPositionOffset.y);\n\n        } else {\n            // ctx.setTransform(maxPixelRatio * quality, 0, 0, maxPixelRatio * quality, 0, 0);\n        }\n    }\n\n\n    moveToPlayer(player) {\n        if (!player) return;\n        if (this.camPosSet) {\n            this.camPosition.x = GameMath.linearInterpolate(this.camPosition.x, player.position.x, 0.03);\n            this.camPosition.y = GameMath.linearInterpolate(this.camPosition.y, player.position.y, 0.03);\n\n        } else {\n            this.camPosition = player.position.clone();\n            this.camPosSet = true;\n        }\n    }\n\n    moveToAbsolutePosition(pos) {\n        this.camPosition = pos;\n    }\n\n\n    loop() {\n        this.camPrevPosition = this.camPosition;\n        this.calCameraOffset();\n    }\n\n\n    getViewPortRec(pos){\n        const viewPortRadius = window.game.viewPortRadius * 2;\n        const leftSide = new Point(\n            pos.x - viewPortRadius,\n            pos.y - viewPortRadius\n        )\n        const rightSide = new Point(\n            pos.x + viewPortRadius,\n            pos.y + viewPortRadius\n        )\n        return new Rectangle(leftSide, rightSide);\n    }\n\n}\n\n\nexport default Camera;","import Point from \"./point.js\";\nimport * as GameMath from \"../../utils/math.js\";\nimport * as GameUtils from \"../utils.js\";\nimport DirectionPacket from \"../../network/packets/direction\";\nimport {log} from \"three/nodes\";\nimport RequestWaitingBlockPacket from \"../../network/packets/requestWaitingBlocks\";\n\n\nclass Player {\n\n    constructor(position = new Point(1, 1), id) {\n        this.id = id\n        this.drawPosSet = false; // from PlayerState Packet\n\n        this.isMyPlayer = false;\n        this.deathWasCertain = false;\n        this.didUncertainDeathLastTick = false;\n        this.isDeathTimer = 0;\n        this.uncertainDeathPosition = new Point(0, 0);\n        this.deadAnimParts = [];\n        this.deadAnimPartsRandDist = [];\n        this.hitLines = [];\n\n        this.position = position\n        this.drawPosition = new Point(-1, -1);\n        this.serverPosition = new Point(0, 0);\n        this.lastChangedDirPos = new Point(0, 0);\n\n\n        this.name = \"\";\n\n\n        // Colors\n        this.colorBrighter = 0;\n        this.colorDarker = 0;\n        this.colorSlightlyBrighter = 0\n        this.colorPattern = 0\n        this.colorPatternEdge = 0\n\n\n        // Movements\n        this.hasReceivedPosition = false; // from PlayerState Packet it set position\n        this.moveRelativeToServerPosNextFrame = false; // from PlayerState Packet\n        this.lastServerPosSentTime = 0;\n\n\n        this.isReady = false;\n        this.isDead = false;\n\n        ///\n        /**\n         * waitingBlocks can be updated vai two messaged only\n         * 1- WaitingBlocksPacket [if player requested waiting blocks]\n         * 2- StopDrawingWaitingBlocksPacket [if player received to stop drawing waiting blocks request is sent to server]\n         * @type {*[]}\n         */\n        this.waitingBlocks = [];\n        this.waitingBlocksDuringWaiting = [];\n        //\n        this.lastPosHasBeenConfirmed = false;\n        this.lastPosServerSentTime = 0;\n        this.myNextDir = '';\n        this.myLastSendDir = '';\n        this.lastDirServerSentTime = 0;\n        this.lastMyPostSetClientSendTime = 0;\n        this.lastConfirmedTimeForPos = 0;\n        this.dir = '';\n        this.sendDirQueue = [];\n        this.clientSideMoves = [];\n        this.changeDirAtCoord = null;\n        this.changeDirAtIsHorizontal = false;\n\n        this.serverPos = new Point(0, 0);\n        this.serverDir = '';\n\n\n        this.waitingForPing = false;\n        this.lastPingTime = 0;\n        this.severLastPing = 0;\n        this.serverAvgPing = 0;\n        this.serverDiffPing = 0;\n\n\n        this.isGettingWaitingBlocks = false;\n        this.skipGettingWaitingBlocksRespose = false;\n        this.waitingPushedDuringReceiving = [];\n\n\n        // animation and drawing\n        this.nameAlphaTimer = 0;\n        this.isDeadTimer = 0;\n\n    }\n\n\n    static getPlayerById(id, players) {\n        for (let p of players) {\n            if (p.id === id) return p;\n        }\n    }\n\n    static isMovingHorizontally(direction) {\n        return direction === 'left' || direction === 'right';\n    }\n\n    static movePlayer(pos, dir, offset) {\n        let workingPos = pos.clone();\n        if (dir === 'up') {\n            workingPos.y -= offset;\n        } else if (dir === 'down') {\n            workingPos.y += offset;\n        } else if (dir === 'left') {\n            workingPos.x -= offset;\n        } else if (dir === 'right') {\n            workingPos.x += offset;\n        }\n        return workingPos;\n\n    }\n\n    static mapControlsToDir(controls) {\n        if (controls === 1) return 'up'; else if (controls === 3) return 'down'; else if (controls === 4) return 'left'; else if (controls === 2) return 'right'; else return '';\n    }\n\n    /**\n     * Verifies if the client's predicted player movement is synchronized with the server's authoritative state.\n     * This function checks the alignment of the player's current or next direction and position against the server's updates.\n     * It is critical for maintaining gameplay integrity by ensuring that all movements rendered client-side are accurate and acknowledged by the server.\n     * This helps prevent discrepancies that can affect game dynamics, such as rubberbanding or desyncs.\n     *\n     * - The function compares the latest direction and position (factoring in calculated offsets for lag) received from the server.\n     * - Returns false if the clients predictions are confirmed by the server (i.e., no update or correction needed),\n     *   which means the player's state on the client matches the server's data.\n     * - Returns true if discrepancies are found, signaling the need for the client to update its local state based on the latest server information.\n     *\n     * Use this function to ensure that the gameplay remains fluid and consistent, avoiding interruptions due to network latency or processing delays.\n     */\n    checkClientMovementSyncedWithServer(newDir, newPosOffset, newPos) {\n        // Check If dir and por are close to current\n        const distVector = this.position.distanceVector(newPosOffset);\n        if ((this.dir === newDir || this.myNextDir === newDir) &&\n            distVector.x < 1 && distVector.y < 1) {\n            return false\n        }\n\n        // check if last client side move is same as new\n        // if server faster than client\n        if (this.clientSideMoves.length > 0) {\n            const lastClientSideMove = this.clientSideMoves.shift()\n            if (lastClientSideMove.dir === newDir\n                && lastClientSideMove.pos.equals(newPos)) {\n                return false\n            } else {\n                this.clientSideMoves = [];\n            }\n        }\n\n        return true\n\n    }\n\n\n    equals(player) {\n        return this.id === player.id;\n    }\n\n\n    /**\n     * Calculate Move Offset Based On Ping And Game Speed\n     * If Player Is Not My Player Or Ping Is Less Than 50 Return 0\n     * 50 ms is the minimum ping to consider the player is synced with the server\n     * so if not my player no need to calculate offset but if my player and ping is bigger than 50\n     * ping [round trip] / 2 * gameSpeed = offset\n     * @returns {number}\n     */\n    calMoveOffset() {\n        let offset = 0;\n        if (!this.isMyPlayer || this.serverAvgPing <= 50) return offset;\n\n        const gameSpeed = window.game.gameSpeed;\n        offset = (this.serverAvgPing / 2) * gameSpeed;\n        return offset;\n    }\n\n\n    addWaitingBlocks(pos = new Point(0, 0)) {\n        if (this.waitingBlocks.length <= 0) return;\n        const lastBlock = this.waitingBlocks.getLast.blocks;\n        if (lastBlock.length <= 0) return;\n        if (!(lastBlock[0].x !== pos.x || lastBlock[0].y !== pos.y)) return;\n        lastBlock.push(pos.clone());\n\n\n        // If Player Change his Direction During Receiving Waiting Blocks\n        if (this.isMyPlayer && this.isGettingWaitingBlocks) {\n            this.waitingPushedDuringReceiving.push(pos);\n        }\n\n    }\n\n    /**\n     * This Function Is Called Every Frame\n     * It Moves The Draw Position To The Position\n     */\n    moveDrawPosToPos() {\n        let target = this.position;\n        this.drawPosition.x = GameMath.linearInterpolate(this.drawPosition.x, target.x, 0.23);\n        this.drawPosition.y = GameMath.linearInterpolate(this.drawPosition.y, target.y, 0.23);\n    }\n\n    /**\n     * Update Player Direction\n     * @param dir\n     */\n    updatePlayerDirection(dir) {\n        this.dir = dir;\n    }\n\n    /**\n     * Check If Player Is Moving Horizontally\n     * @param direction\n     * @returns {boolean}\n     */\n    isMovingHorizontally(direction = this.dir) {\n        return direction === 'left' || direction === 'right';\n    }\n\n    /**\n     * Update Player Position\n     * @param pos\n     */\n    updatePlayerPosition(pos) {\n        this.position = pos;\n    }\n\n    /**\n     * This Is Called In PlayerState Message\n     * To Remove Blocks Outside Camera\n     */\n    removeBlocksOutsideCamera() {\n        const camera = window.camera;\n        const playerRect = camera.getViewPortRec(this.position);\n        const blocks = window.gameEngine.gameObjects.blocks;\n        for (let i = 0; i < blocks.length; i++) {\n            const block = blocks[i];\n            if (!playerRect.pointInRect(block.position)) {\n                blocks.splice(i, 1);\n            }\n        }\n    }\n\n    /**\n     * This Function Is Called Every Frame\n     * It Checks If The Player Should Change Direction\n     * Based On Next Direction If It Should Change Direction\n     */\n    checkNextDirAndCamera() {\n\n        if (!this.isMyPlayer) return;\n\n        const camera = window.camera;\n        camera.moveToPlayer(this)\n\n\n        if (this.myNextDir === this.dir) return;\n\n        const isHorizontal = this.isMovingHorizontally(this.dir);\n        if (this.changeDirAtIsHorizontal !== isHorizontal) return;\n\n\n        let changeDirectionCurrentFrame = false;\n        const currentCoord = isHorizontal ? this.position.x : this.position.y;\n\n        // Check If Last Direction passed the point that player requested to change direction\n        if (GameUtils.isMovingToPositiveDir(this.dir)) {\n            if (this.changeDirAtCoord < currentCoord) changeDirectionCurrentFrame = true;\n        } else {\n            if (this.changeDirAtCoord > currentCoord) changeDirectionCurrentFrame = true;\n        }\n\n\n        if (changeDirectionCurrentFrame) {\n            const newPos = this.position.clone();\n            const distance = Math.abs(this.changeDirAtCoord - currentCoord);\n            if (isHorizontal)\n                newPos.x = this.changeDirAtCoord;\n            else\n                newPos.y = this.changeDirAtCoord;\n            this.changeCurrentDir(this.myNextDir, newPos);\n            let offsetPosition = Player.movePlayer(this.position, this.dir, distance);\n            this.updatePlayerPosition(offsetPosition);\n        }\n\n    }\n\n    /**\n     * Change Player Direction and Position\n     * Add Waiting Blocks\n     * Add Client Side Move To Check If Server Synced With Client in PlayerState Message\n     * @param dir\n     * @param pos\n     * @param addWaitingBlocks\n     * @param clientDecision\n     */\n    changeCurrentDir(dir, pos, addWaitingBlocks = true, clientDecision = true) {\n        this.updatePlayerDirection(dir);\n        this.myNextDir = dir;\n\n        this.updatePlayerPosition(pos.clone());\n        this.lastChangedDirPos = pos.clone();\n\n\n        if (addWaitingBlocks) {\n            this.addWaitingBlocks(pos);\n        }\n\n\n        // To Check If Player Movement is Synced With Server in\n        // PlayerState Message\n        if (clientDecision) {\n            this.clientSideMoves.push({\n                dir: dir, pos: pos.clone(), time: Date.now()\n            });\n        }\n\n    }\n\n\n    ////////////// DRAWING /////////////////\n    drawPlayerHeadWithEye(ctx) {\n        let newDrawPos = new Point(this.drawPosition.x * 10 + 4.5, this.drawPosition.y * 10 + 4.5);\n        const bigEye = \"#ffff\";\n        const smallEye = \"#000\";\n        let radius = 6;\n        let size = radius;\n        const animationSpeed = 0.005;\n        const eyeAnimation = Math.sin(Date.now() * animationSpeed) * 2;\n        let r = 0.5;\n\n        const gradient = ctx.createRadialGradient(newDrawPos.x - 3, newDrawPos.y - 3, 0, newDrawPos.x, newDrawPos.y, radius);\n        gradient.addColorStop(0, this.colorSlightlyBrighter);\n        gradient.addColorStop(1, this.colorBrighter);\n\n        const c = ctx;\n        c.translate(newDrawPos.x, newDrawPos.y);\n\n        if (this.dir === 'up') {\n            c.rotate(Math.PI * r);\n        } else if (this.dir === 'down') {\n            r += .5 * 2;\n            c.rotate(Math.PI * r);\n        } else if (this.dir === 'left') {\n            r += .5 * 3;\n            c.rotate(Math.PI * r);\n        } else {\n            r += .5;\n            c.rotate(Math.PI * r);\n        }\n\n        c.beginPath();\n        c.arc(0, 0, size, 0, Math.PI * 2, false);\n\n        c.fillStyle = gradient;\n        c.fill();\n\n        // Draw the left white eye\n        c.beginPath();\n        c.fillStyle = bigEye;\n        c.arc(-size / 2, -size / 2.5, size / 4, 0, Math.PI * 2, false);\n        c.fill();\n\n        // Draw the left black eye\n        c.beginPath();\n        c.fillStyle = smallEye;\n        c.arc(-size / 2, -size / 2.5 + eyeAnimation, size / 8, 0, Math.PI * 2, false);\n        c.fill();\n\n        // Draw the right white eye\n        c.beginPath();\n        c.fillStyle = bigEye;\n        c.arc(-size / 2, size / 2.5, size / 4, 0, Math.PI * 2, false);\n        c.fill();\n\n        // Draw the right black eye\n        c.beginPath();\n        c.fillStyle = smallEye;\n        c.arc(-size / 2, size / 2.5 + eyeAnimation, size / 8, 0, Math.PI * 2, false);\n        c.fill();\n\n        // Smile\n        c.beginPath();\n        c.arc(size / 4, 0, size / 2, -0.5 * Math.PI, 0.5 * Math.PI);\n        c.lineWidth = size / 10;\n        c.stroke();\n\n        c.restore();\n        window.gameEngine.camTransform(ctx);\n\n    }\n\n    drawWaitingBlocks(ctx) {\n        if (this.waitingBlocks.length <= 0) return;\n        const gameSpeed = window.game.gameSpeed;\n        const deltaTime = window.gameEngine.deltaTime;\n\n\n        for (let blockIndex = this.waitingBlocks.length - 1; blockIndex >= 0; blockIndex--) {\n            let block = this.waitingBlocks[blockIndex];\n            let isLastBlock = blockIndex === this.waitingBlocks.length - 1;\n\n\n            // remove Top Block From Waiting Blocks If It's Vanish Timer Is More Than 10\n            if (!isLastBlock || this.isDead) {\n                let speed = (this.isDead && isLastBlock) ? gameSpeed : 0.02;\n                block.vanishTimer += deltaTime * speed;\n                if (!isLastBlock && (block.vanishTimer > 10)) {\n                    this.waitingBlocks.splice(blockIndex, 1);\n                }\n            }\n\n            let helperCanvas = window.game.helperCtx.canvas;\n            let helperCtx = window.game.helperCtx;\n\n            if (block.blocks.length <= 0) continue;\n\n            const lastDrawPos = isLastBlock ? this.drawPosition : null;\n\n            if (block.vanishTimer > 0) {\n                window.gameEngine.camTransform(helperCtx, true);\n\n\n                this.drawWaitingBlockInCTX([\n                    {ctx: helperCtx, color: this.colorDarker, offset: 5},\n                    {ctx: helperCtx, color: this.colorBrighter, offset: 4},\n                ], block.blocks, lastDrawPos);\n\n\n                helperCtx.globalCompositeOperation = 'destination-out';\n\n                ctx.restore();\n                helperCtx.restore();\n\n                ctx.drawImage(helperCanvas, 0, 0);\n\n                helperCtx.fillStyle = '#c7c7c7';\n                helperCtx.globalCompositeOperation = \"source-in\";\n                helperCtx.fillRect(0, 0, helperCanvas.width, helperCanvas.height);\n                window.gameEngine.camTransform(ctx);\n\n            } else if (block.vanishTimer < 10) {\n                this.drawWaitingBlockInCTX([\n                    {ctx: ctx, color: this.colorDarker, offset: 6},\n                    {ctx: ctx, color: this.colorBrighter, offset: 4},\n                ], block.blocks, lastDrawPos);\n            }\n\n\n        }\n\n\n    }\n\n    drawWaitingBlockInCTX(contexts, blocks, lastPosition) {\n        if (blocks.length <= 0) return;\n\n\n        for (let ctxIndex = 0; ctxIndex < contexts.length; ctxIndex++) {\n            let b = contexts[ctxIndex];\n            let ctx = b.ctx;\n            let offset = b.offset;\n            ctx.lineCap = \"round\";\n            ctx.lineJoin = \"round\";\n            ctx.lineWidth = 6;\n            ctx.strokeStyle = b.color;\n            ctx.beginPath();\n            ctx.moveTo(blocks[0].x * 10 + offset, blocks[0].y * 10 + offset);\n            for (let i = 1; i < blocks.length; i++) {\n                ctx.lineTo(blocks[i].x * 10 + offset, blocks[i].y * 10 + offset);\n            }\n            if (lastPosition !== null) {\n                ctx.lineTo(lastPosition.x * 10 + offset, lastPosition.y * 10 + offset);\n            }\n            ctx.stroke();\n        }\n    }\n\n    draw(ctx) {\n        if (!this.isReady) return; // from Ready Packet\n        if (!this.hasReceivedPosition) return; // from PlayerState Packet\n        const gameSpeed = window.game.gameSpeed;\n        let offset = window.gameEngine.deltaTime * gameSpeed;\n\n        if (!window.gameEngine.gameObjects.isPlayerExist(this)) return;\n\n\n        // When Receiving Player State Next Frame Move Relative To Server Pos\n        if (this.moveRelativeToServerPosNextFrame) {\n            // When Receiving Player State\n            // Next Frame Move Relative To Server Pos\n            offset = (Date.now() - this.lastServerPosSentTime) * gameSpeed;\n            this.moveRelativeToServerPosNextFrame = false;\n        }\n\n        if (this.isMyPlayer) {\n            this.serverPos = Player.movePlayer(this.serverPos, this.serverDir, offset);\n\n            // Check If Client Movement As Same As Server Direction Received From Server in PlayerState Message\n            if (this.serverDir === this.dir) {\n                let clientSideDist = 0;\n                if (Player.isMovingHorizontally(this.dir)) {\n                    if (this.position.y === this.serverPos.y) {\n                        if (this.dir === 'right') {\n                            clientSideDist = this.position.x - this.serverPos.x;\n                        } else {\n                            clientSideDist = this.serverPos.x - this.position.x;\n                        }\n                    }\n                } else {\n                    if (this.position.x === this.serverPos.x) {\n                        if (this.dir === 'down') {\n                            clientSideDist = this.position.y - this.serverPos.y;\n                        } else {\n                            clientSideDist = this.serverPos.y - this.position.y;\n                        }\n                    }\n                }\n                clientSideDist = Math.max(0, clientSideDist);\n                offset *= GameMath.linearInterpolate(.5, 1, GameMath.inverseLinearInterpolate(5, 0, clientSideDist));\n            }\n        }\n\n\n        let offsetPosition = Player.movePlayer(this.position, this.dir, offset);\n        if (!this.positionInWalls(offsetPosition))\n            this.updatePlayerPosition(offsetPosition);\n\n\n        this.moveDrawPosToPos();\n        this.checkNextDirAndCamera();\n        this.drawWaitingBlocks(ctx);\n        this.drawPlayerHeadWithEye(ctx);\n        this.drawPlayerName(ctx)\n        this.parseDirQueue();\n\n    }\n\n\n    drawPlayerName(ctx) {\n        this.nameAlphaTimer += window.gameEngine.deltaTime * 0.001;\n        const userNameSize = 6;\n        ctx.font = `${userNameSize}px Arial, Helvetica, sans-serif`;\n        let myAlpha = 1;\n        let deadAlpha = 1;\n        if (this.isMyPlayer) {\n            myAlpha = 9 - this.nameAlphaTimer;\n        }\n        if (this.isDead) {\n            deadAlpha = 1 - this.isDeadTimer;\n        }\n        let alpha = Math.min(myAlpha, deadAlpha);\n        // if (alpha <= 0) return;\n\n        ctx.save();\n        // ctx.globalAlpha = GameMath.clamp(alpha, 0, 1);\n        let realNameWidth = ctx.measureText(this.name).width;\n        let nameWidth = Math.max(100, realNameWidth);\n\n        const maxNamePos = new Point((this.drawPosition.x * 10) + 5 - (nameWidth / 2), this.drawPosition.y * 10 - 5);\n        // center the width i we have a space\n\n\n        const namePos = new Point(maxNamePos.x, maxNamePos.y);\n        const distanceToMax = this.drawPosition.multiply(10).distanceVector(maxNamePos).abs();\n        namePos.x = Math.abs(distanceToMax.x - realNameWidth)/2 + maxNamePos.x;\n\n\n        ctx.rect(namePos.x - 4, namePos.y - userNameSize * 1.2, nameWidth + 8, userNameSize * 2);\n        ctx.clip();\n\n        ctx.shadowColor = \"rgba(0,0,0,0.9)\";\n        ctx.shadowBlur = 10;\n        ctx.shadowOffsetX = ctx.shadowOffsetY = 2;\n        ctx.fillStyle = this.colorBrighter;\n        ctx.fillText(this.name, namePos.x, namePos.y);\n\n        ctx.shadowColor = this.colorDarker;\n        ctx.shadowBlur = 0;\n        ctx.shadowOffsetX = ctx.shadowOffsetY = 0.8;\n        ctx.fillText(this.name, namePos.x, namePos.y);\n\n        ctx.restore();\n\n\n    }\n\n    ///////////////////////////////////\n\n    checkIfPositionSentEarlier(pos) {\n        return false; // TODO: Fix This\n        // console.log(pos, this.lastChangedDirPos, \"E\");\n\n\n        if (this.dir === 'up' && pos.y >= this.lastChangedDirPos.y) return true;\n        else if (this.dir === 'down' && pos.y <= this.lastChangedDirPos.y) return true;\n        else if (this.dir === 'left' && pos.x >= this.lastChangedDirPos.x) return true;\n        else return this.dir === 'right' && pos.x <= this.lastChangedDirPos.x;\n    }\n\n\n    positionInWalls(pos) {\n        const mapSize = window.gameEngine.gameObjects.mapSize - 1;\n        const playerPositionFloored = pos.floorVector();\n        const playerPositionCelled = pos.ceilVector();\n        const minBoundary = new Point(0, 0);\n        const maxBoundary = new Point(mapSize, mapSize);\n\n        return (playerPositionFloored.x <= minBoundary.x ||\n            playerPositionCelled.x >= maxBoundary.x ||\n            playerPositionFloored.y <= minBoundary.y ||\n            playerPositionCelled.y >= maxBoundary.y)\n    }\n\n    requestChangeDir(direction, skipQueue = false) {\n        const dir = direction;\n        const gameSpeed = window.game.gameSpeed;\n        const timePassedFromLastSend = Date.now() - this.lastDirServerSentTime;\n        const minTimeToWaitToSendDir = 0.7 / gameSpeed;\n\n\n        // Prevent Sending Same Dir\n        // Prevent Sending Dir Too Fast\n        if (dir === this.myLastSendDir && timePassedFromLastSend < minTimeToWaitToSendDir) {\n            return false;\n        }\n        this.myLastSendDir = dir;\n        this.lastDirServerSentTime = Date.now();\n\n\n        // Check If Dir Is Same As Current Dir\n        if (this.dir === dir) {\n            return false;\n        }\n\n        // Check If Dir Is Opposite Of Current Dir\n        if (GameUtils.isOppositeDir(dir, this.dir)) {\n            return false;\n        }\n\n        // Round Player Position To The Nearest Integer\n        const isHorizontal = this.isMovingHorizontally(this.dir);\n\n        const valueToRound = isHorizontal ? this.position.x : this.position.y;\n        const roundedValue = Math.round(valueToRound);\n        const newPlayerPos = this.position.clone();\n        if (isHorizontal) newPlayerPos.x = roundedValue;\n        else newPlayerPos.y = roundedValue;\n\n        // Check If Position Corrupted Since Last Send\n        if (this.checkIfPositionSentEarlier(newPlayerPos)) {\n            console.log(\"GameUtils.checkIfPositionSentEarlier(dir, this.dir)\");\n            this.addDirToQueue(dir, skipQueue);\n            return false;\n        }\n\n\n        console.log(\"Position Passed\")\n        // Check If Last Direction Complete passed .55 Of Current Block\n        let changeDirectionCurrentFrame = false;\n\n        const blockProgress = valueToRound - Math.floor(valueToRound);\n        if (GameUtils.isMovingToPositiveDir(dir)) {\n            if (blockProgress < .45)\n                changeDirectionCurrentFrame = true;\n        } else if (blockProgress > .55)\n            changeDirectionCurrentFrame = true;\n\n\n        // Check If Prediction Of Next Direction Will Touch Wall\n        // We Change It Now Not in Next Frame\n        // Because checkNextDirAndCamera function will not change the direction\n        // Because the player is not moving to the next block\n        // as it prevented from move in main update function\n        let predictionVector = this.position.clone();\n        predictionVector = Player.movePlayer(predictionVector, this.dir, 1);\n\n        if (this.positionInWalls(predictionVector))\n            changeDirectionCurrentFrame = true;\n\n\n        if (changeDirectionCurrentFrame) {\n            this.changeCurrentDir(dir, newPlayerPos);\n        } else {\n            // change direction in next frame\n            // this movement will be done in next frame not now\n            this.myNextDir = dir;\n            this.changeDirAtCoord = roundedValue;\n            this.changeDirAtIsHorizontal = isHorizontal;\n            this.lastChangedDirPos = newPlayerPos.clone();\n        }\n\n\n        // Last Send Time\n        // Last Confirmed Time\n        this.lastMyPostSetClientSendTime = Date.now();\n        if (this.lastPosHasBeenConfirmed) {\n            this.lastConfirmedTimeForPos = Date.now();\n            this.lastPosHasBeenConfirmed = false;\n        }\n\n\n        // We Send The Position and Dir To Server\n        // To Make Server Sync With Client\n        const packet = new DirectionPacket(dir, newPlayerPos);\n        window.client.send(packet);\n        return true;\n    }\n\n\n    parseDirQueue() {\n\n        if (this.sendDirQueue.length <= 0) return;\n        const firstDir = this.sendDirQueue.first;\n        const timePassed = (Date.now() - firstDir.time);\n        const gameSpeed = window.game.gameSpeed;\n        const minTimeToWaitToSendDir = 1.2 / gameSpeed;\n\n        /// Check If Time Passed From Last Send Is Less Than minTimeToWaitToSendDir\n        if (timePassed < minTimeToWaitToSendDir || this.requestChangeDir(firstDir.dir, true)) {\n            this.sendDirQueue.shift();\n        }\n    }\n\n    addDirToQueue(dir, skip = false) {\n        if (!skip && this.sendDirQueue.length < 3) {\n            this.sendDirQueue.push({\n                dir: dir, time: Date.now()\n            });\n        }\n    }\n\n    /**\n     * Request Waiting Blocks For Two Reasons\n     * 1- If server thinks during player movement then some waiting blocks were missed so we request it\n\n     the RequestWaitingBlocks could happen if we found server and client blocks are not synced\n     in Player State Packet\n\n\n\n     */\n    requestWaitingBlocks() {\n        this.isGettingWaitingBlocks = true;\n        this.waitingPushedDuringReceiving = [];\n        const packet = new RequestWaitingBlockPacket();\n        window.client.send(packet);\n    }\n\n\n    drawPlayerHead(ctx) {\n        let newDrawPos = new Point(this.drawPosition.x * 10 + 4.5, this.drawPosition.y * 10 + 4.5);\n        let radius = 6;\n        let shadowOffset = .3;\n\n        const gradient = ctx.createRadialGradient(newDrawPos.x - 3, newDrawPos.y - 3, 0, newDrawPos.x, newDrawPos.y, radius);\n        gradient.addColorStop(0, this.colorSlightlyBrighter);\n        gradient.addColorStop(1, this.colorBrighter);\n        if (false) {\n\n        } else {\n            ctx.fillStyle = this.colorDarker;\n            ctx.beginPath();\n            ctx.arc(newDrawPos.x + shadowOffset, newDrawPos.y + shadowOffset, radius, 0, Math.PI * 2, false);\n            ctx.fill();\n            ctx.fillStyle = gradient;\n            ctx.beginPath();\n            ctx.arc(newDrawPos.x - shadowOffset, newDrawPos.y - shadowOffset, radius, 0, Math.PI * 2, false);\n            ctx.fill();\n            if (this.isMyPlayer) {\n                ctx.fillStyle = \"#ffffff\";\n                ctx.beginPath();\n                ctx.arc(newDrawPos.x - shadowOffset, newDrawPos.y - shadowOffset, 1, 0, Math.PI * 2, false);\n                ctx.fill();\n            }\n        }\n    }\n}\n\n\nexport default Player;","class Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    equals(otherPoint) {\n        return this.x === otherPoint.x && this.y === otherPoint.y;\n    }\n\n    distanceVector(otherPoint) {\n        return new Point(Math.abs(this.x - otherPoint.x), Math.abs(this.y - otherPoint.y));\n    }\n\n\n    multiply(scalar) {\n        return new Point(this.x * scalar, this.y * scalar);\n    }\n\n\n    clone() {\n        return new Point(this.x, this.y);\n    }\n\n\n    floorVector()\n    {\n        return new Point(Math.floor(this.x),Math.floor(this.y));\n    }\n\n    ceilVector()\n    {\n        return new Point(Math.ceil(this.x),Math.ceil(this.y));\n    }\n\n    abs(){\n        return new Point(Math.abs(this.x),Math.abs(this.y));\n    }\n\n\n}\n\nexport default Point;","import Point from './point.js';\nclass Rectangle {\n    constructor(minVec, maxVec) {\n        this.min = minVec;\n        this.max = maxVec;\n    }\n\n    toString() {\n        return `<Rectangle min=${this.min} max=${this.max}>`;\n    }\n\n    clamp(rect) {\n        const minVec = new Point(\n            Math.max(this.min.x, rect.min.x),\n            Math.max(this.min.y, rect.min.y)\n        );\n\n        const maxVec = new Point(\n            Math.min(this.max.x, rect.max.x),\n            Math.min(this.max.y, rect.max.y)\n        );\n\n        return new Rectangle(minVec, maxVec);\n    }\n\n    *for_each() {\n        for (let x = this.min.x; x < this.max.x; x++) {\n            for (let y = this.min.y; y < this.max.y; y++) {\n                yield { x, y };\n            }\n        }\n    }\n\n    isRectOverlap(rect) {\n        return (\n            this.min.x < rect.max.x &&\n            this.max.x > rect.min.x &&\n            this.min.y < rect.max.y &&\n            this.max.y > rect.min.y\n        );\n    }\n\n    isNotRectOverlap(rect) {\n        return (\n            this.max.x < rect.min.x ||\n            this.min.x > rect.max.x ||\n            this.max.y < rect.min.y ||\n            this.min.y > rect.max.y\n        );\n    }\n\n\n    pointInRect(point) {\n        return (\n            point.x >= this.min.x &&\n            point.x <= this.max.x &&\n            point.y >= this.min.y &&\n            point.y <= this.max.y\n        );\n    }\n}\n\nexport default Rectangle;","const getHeight = () => window.innerHeight;\nconst getWidth = () => window.innerWidth;\n\nconst calculate_pixel_ratio = () => {\n    let context = document.createElement(\"canvas\").getContext(\"2d\");\n    let dpr = window.devicePixelRatio || 1;\n    let bsr = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;\n    return dpr / bsr;\n}\n\nconst ease = {\n    in: function (t) {\n        return t * t * t * t;\n    },\n    out: function (t) {\n        return 1 - Math.pow(1 - t, 4);\n    },\n    inout: function (t) {\n        return t < 0.5 ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2;\n    },\n};\n\n\nconst drawInCtxRec = (ctx, point, size, color, spacing = 0) => {\n    ctx.fillStyle = color;\n    ctx.fillRect(point.x + spacing, point.y + spacing, size, size);\n}\n\n\nconst convertIntColorToHex = (color) => {\n    return \"#\" + (\"000000\" + color.toString(16)).slice(-6);\n}\n\n\nconst isOppositeDir = (newDir, OldDir) => {\n    if (newDir === 'up' && OldDir === 'down')\n        return true;\n    else if (newDir === 'down' && OldDir === 'up')\n        return true;\n    else if (newDir === 'left' && OldDir === 'right')\n        return true;\n    else return newDir === 'right' && OldDir === 'left';\n\n}\n\nconst isVerticalDir = (dir) => {\n    return dir === 'up' || dir === 'down';\n}\n\nconst isMovingToPositiveDir = (dir) => {\n    return dir === 'down' || dir === 'right';\n\n}\n\nexport {isMovingToPositiveDir,isVerticalDir,isOppositeDir, convertIntColorToHex, getHeight, getWidth, calculate_pixel_ratio, ease, drawInCtxRec}","const linearInterpolate = (a, b, v) => {\n    return a + (b - a) * v;\n}\n\n\nconst inverseLinearInterpolate = (a, b, v) => {\n    return (v - a) / (b - a);\n}\n\nconst adaptedLinearInterpolate = (a, b, val1, val2) => {\n    let x = 1 - Math.pow((1 - val1), val2);\n    return linearInterpolate(a, b, x);\n};\n\nconst adaptedConLinearInterpolate = (val2) => (a, b, val1) => {\n    return adaptedLinearInterpolate(a, b, val1, val2);\n}\n\nconst smoothLimit = (v) => {\n    let negative = v < 0;\n    if (negative) {\n        v *= -1;\n    }\n    v = 1 - Math.pow(2, -v);\n    if (negative) {\n        v *= -1;\n    }\n    return v;\n}\n\nconst clamp = (val, min, max) => {\n    return Math.max(min, Math.min(max, val));\n}\n\n\nconst calPercentage = (a, percentage) => a * percentage;\n\nexport {\n    linearInterpolate, inverseLinearInterpolate, adaptedLinearInterpolate, adaptedConLinearInterpolate\n    , clamp , smoothLimit,calPercentage\n};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import Camera from './ui/objects/camera.js';\nimport GameEngine from \"./gameEngine\";\nimport {Client} from \"./network/client\";\nimport \"./globals.js\";\nimport \"./controls.js\";\nimport \"./extensions/arraysExtensions.js\";\n\n\nconst camera = new Camera();\nconst gameEngine = new GameEngine(60);\n\nlet canvas = document.getElementById(\"canvas\");\nlet ctx = canvas.getContext(\"2d\");\nlet blocks = gameEngine.gameObjects.blocks;\nlet players = gameEngine.gameObjects.players;\n\nlet helperCanvas = document.createElement(\"canvas\");\nlet helperCtx = helperCanvas.getContext(\"2d\");\n\nwindow.game.helperCtx = helperCtx;\nwindow.gameEngine = gameEngine;\nwindow.camera = camera;\nwindow.game.canvas = canvas;\n\nlet client = null;\nlet myPlayer = null;\n\nconst draw = () => {\n    if (client && client.player) myPlayer = client.player;\n\n    gameEngine.scaleCanvas(ctx);\n    ctx.fillStyle = \"#3a3428\";\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    camera.loop()\n    gameEngine.camTransform(ctx);\n\n\n    // console.log(\"Blocks: \" + blocks.length);\n    for (let b of blocks) {\n        b.draw(ctx, false);\n    }\n\n    for (let p in players) {\n        players[p].draw(ctx);\n    }\n\n    if (client && client.player) myPlayer.removeBlocksOutsideCamera();\n\n}\n\n\ngameEngine.setDrawFunction(draw);\n\n\nwindow.requestAnimationFrame(gameEngine.loop.bind(gameEngine));\n\nclient = new Client('ws://127.0.0.1:5000/game', (client) => {\n    client.setPlayerName(\"Test\");\n});\n\n\n"],"names":[],"sourceRoot":""}